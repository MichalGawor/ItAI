b'' b'for your application, what you can do is to encrypt the real-time clock' b'value with a secret key.' b'' b'well, almost.... if i only had to solve the problem for myself, and were' b'willing to have to type in a second password (the secret key) whenever i' b"logged in, it could work. however, i'm trying to create a solution that" b'anyone can use, and which, once installed, is just as effortless to start up' b"as the non-solution of just using xhost(1) to control access. i've got" b'religeous problems with storing secret keys on multiuser computers.' b'' b'for a good discussion of cryptographically "good" random number' b'generators, check out the draft-ietf-security-randomness-00.txt' b'internet draft, available at your local friendly internet drafts' b'repository.' b'' b'thanks for the pointer! it was good reading, and i liked the idea of using' b'several unrelated sources with a strong mixing function. however, unless i' b'missed something, the only source they suggested (aside from a hardware rng)' b'that seems available, and unguessable by an intruder, when a unix is' b'fresh-booted, is i/o buffers related to network traffic. i believe my' b'solution basically uses that strategy, without requiring me to reach into' b'the kernel.' b'' b'a reasonably source of randomness is the output of a cryptographic' b'hash function (e.g., md5), when fed with a large amount of' b'more-or-less random data. for example, running md5 on /dev/mem is a' b'slow, but random enough, source of random bits; there are bound to be' b'128 bits of entropy in the tens (or hundreds) of megabytes of data in' b"a modern workstation's memory, as a fair amount of them are system" b'timers, i/o buffers, etc.' b'' b'i heard about this solution, and it sounded good. then i heard that folks' b'were experiencing times of seconds to run this, on' b"reasonably-configured workstations. i'm not willing to add that much delay" b"to someone's login process. my approach (etherfind|compress, skip 10k) takes" b"a second or two to run. i'm considering writing the be-all and end-all of" b'solutions, that launches the md5, and simultaneously tries to suck bits off' b"the net, and if the net should be sitting __so__ idle that it can't get 10k" b'after compression before md5 finishes, use the md5. this way i could have' b'guaranteed good bits, and a deterministic upper bound on login time, and' b'still have the common case of login take only a couple of extra seconds.' b'' b'-bennett' 