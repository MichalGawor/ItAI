b'' b':i tried this code yesterday. on my sparcstation elc it takes over' b":300 seconds to compress seconds' worth of speech. this means that it" b':needs to be "optimized" by over a factor of before it will be usable' b':in even a half-duplex mode.' b'' b'ouch! thanks for trying it.' b'' b'the following program is a very quick hack i created a few months' b'ago to determine whether a sun sparcstation ipc could perform' b'real-time, full-duplex encrypted audio with resulting data rates' b"sustainable by today's modems." b'' b'this test program reads linearly-encoded audio from the audio device,' b'compresses it with gsm (compresses frames of 13-bit samples' b'recorded at 8khz into bits resulting in a hz frame rate), encrypts' b'it with des, then reverses the process and sends the reconstructed audio' b'back to the audio device. the compressed, encrypted audio stream' b'is kbits/s b'' b'my sparcstation ipc (not exactly a very fast machine these days,' b'certainly slower than an elc) would just barely sustain this activity' b'(audio underruns would occcur but the speech was very intelligible). i' b'ran it as a real-time process to get the best results. remember,' b'though, that this program is a quick hack and the performance can' b'certainly be improved.' b'' b"the audio compression routines can be ftp'd from tub.cs.tu-berlin.de," b"i believe (look for gsm or toast). i used eric young's des" b'implementation but i no longer know where i got it from.' b'' b'cheers!greg' b'' b'<--------------------------- cut here b'/*' b'* test program to see how much cpu it takes for secure digital audio.' b'*' b'* written on a sun ipc running solaris with a sun isdn s-bus card' b'* and a speakerbox.' b'*/' b'#include <stdlib.h' b'#include <unistd.h' b'#include <fcntl.h' b'#include <stdio.h' b'#include <sys/types.h' b'#include <sys/audioio.h' b'#include <stropts.h' b'' b'#include <gsm.h' b'#include <des.h' b'' b'boolean_t' b'svs_audio_init(int fd, audio_info_t *prev_info)' b'{' b'audio_info_t info;' b'' b'if (prev_info null) b'if (ioctl(fd, audio_getinfo, prev_info) b'perror("audio_getinfo");' b'return (b_false);' b'}' b'}' b'' b'audio_initinfo(&info);' b'' b'info.record.pause b_true;' b'info.play.pause b_true;' b'' b'info.play.sample_rate b'info.play.encoding audio_encoding_linear;' b'info.play.channels b'info.play.precision b'info.record.sample_rate b'info.record.encoding audio_encoding_linear;' b'info.record.channels b'info.record.precision b'' b'info.record.buffer_size b'' b'if (ioctl(fd, audio_setinfo, &info) b'perror("audio_setinfo");' b'return (b_false);' b'}' b'' b'if (ioctl(fd, i_flush, flushrw) b'perror("i_flush");' b'return (b_false);' b'}' b'' b'' b'audio_initinfo(&info);' b'' b'info.record.pause b_false;' b'info.play.pause b_false;' b'' b'if (ioctl(fd, audio_setinfo, &info) b'perror("audio_setinfo");' b'return (b_false);' b'}' b'' b'return (b_true);' b'}' b'' b'' b'boolean_t' b'svs_in(int ifd, gsm handle, gsm_byte *buf)' b'{' b'gsm_signal sample[160];' b'' b'if (read(ifd, sample, sizeof (sample)) sizeof (sample)) b'fprintf(stderr, "svs_in: short read\\n");' b'return (b_false);' b'}' b'' b'gsm_encode(handle, sample, buf);' b'' b'return (b_true);' b'}' b'' b'' b'boolean_t' b'svs_out(int ofd, gsm handle, gsm_byte *buf)' b'{' b'gsm_signal sample[160];' b'' b'if (gsm_decode(handle, buf, sample) b'fprintf(stderr, "svs_out: gsm_decode failed\\n");' b'return (b_false);' b'}' b'' b'if (write(ofd, sample, sizeof (sample)) sizeof (sample)) b'fprintf(stderr, "svs_out: short write\\n");' b'return (b_false);' b'}' b'' b'return (b_true);' b'}' b'' b'' b'main()' b'{' b'gsm handle;' b'gsm_frame frame;' b'int audiofd;' b'int option;' b'des_cblock key, ivec_in, ivec_out;' b'des_key_schedule ks_in, ks_out;' b'des_cblock cbuf_in[4], cbuf_out[4], cbuf_buf[4];' b'' b'audiofd open("/dev/audio", o_rdwr);' b'if (audiofd b'perror("open");' b'exit(4);' b'}' b'' b'/*' b'* initialize gsm compression code' b'*/' b'if ((handle gsm_create()) null) b'fprintf(stderr, "svs: gsm_create failed\\n");' b'exit(4);' b'}' b'' b'option b_true;' b'if (gsm_option(handle, gsm_opt_fast, &option) b'fprintf(stderr, "svs: gsm_option (fast) failed\\n");' b'exit(4);' b'}' b'' b'/*' b'* initialize des code' b'*/' b'des_random_key(&key);' b'' b'if (des_set_key(&key, ks_in) b'fprintf(stderr, "svs: des_set_key failed\\n");' b'exit(4);' b'}' b'if (des_set_key(&key, ks_out) b'fprintf(stderr, "svs: des_set_key failed\\n");' b'exit(4);' b'}' b'memset(ivec_in, sizeof (ivec_in));' b'memset(ivec_out, sizeof (ivec_out));' b'' b'/*' b'* open audio device and configure it' b'*/' b'if (!svs_audio_init(audiofd, null))' b'exit(3);' b'' b'for b'/*' b'* get samples (16-bit linear 8000hz) and' b'* convert to a byte frame' b'*/' b'if (!svs_in(audiofd, handle, frame))' b'exit(1);' b'' b'/*' b'* encrypt/decrypt block' b'*/' b'des_cbc_encrypt(frame, cbuf_out, (long)32, ks_in, ivec_in,' b'des_encrypt);' b'des_cbc_encrypt(cbuf_out, cbuf_buf, (long)32, ks_out, ivec_out,' b'des_decrypt);' b'' b'memmove(frame, cbuf_buf, b'' b'#if b'if (memcmp(cbuf_in, cbuf_buf, b'fprintf(stderr, "svs: memcmp failed\\n");' b'exit(4);' b'}' b'#endif' b'' b'/*' b'* take byte frame and convert to samples' b'* and play' b'*/' b'if (!svs_out(audiofd, handle, frame))' b'exit(2);' b'}' b'' b'gsm_destroy(handle);' b'}' b'<--------------------------- cut here 