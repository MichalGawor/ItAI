b'' b'archive-name: x-faq/part5' b'last-modified: b'' b'----------------------------------------------------------------------' b'' b'float resources are not portable; the size of the value may be larger than' b'the size of an xtpointer. try using a pointer to a float instead; the xaw' b'scrollbar float resources are handled in this way.' b'' b'----------------------------------------------------------------------' b'' b'yes. this is the "unofficial" fix-19 for the x11r4 destroy.c:' b'' b'*** destroy.c.1.37\tthu jul b'--- lib/xt/destroy.c\tthu jul b'***************' b'*** b'--- b'/* $xconsortium: destroy.c,v swick exp b'+ plus unofficial patches in revisions and b'' b'/***********************************************************' b'copyright by digital equipment corporation, maynard, massachusetts,' b'***************' b'*** b'*/' b'' b'int i b'! destroyrec* dr app-destroy_list;' b'while (i app-destroy_count) b'if (dr-dispatch_level dispatch_level) b'widget w dr-widget;' b'if (--app-destroy_count)' b'bcopy( (char*)(dr+1), (char*)dr,' b'! \t\t app-destroy_count*sizeof(destroyrec)' b');' b'xtphase2destroy(w);' b'}' b'else b'i++;' b'- \t dr++;' b'}' b'}' b'}' b'--- b'*/' b'' b'int i b'! destroyrec* dr;' b'while (i app-destroy_count) b'+' b'+ \t/* xtphase2destroy can result in calls to xtdestroywidget,' b'+ \t and these could cause app-destroy_list to be reallocated.' b'+ \t b'+' b'+ \tdr app-destroy_list i;' b'if (dr-dispatch_level dispatch_level) b'widget w dr-widget;' b'if (--app-destroy_count)' b'bcopy( (char*)(dr+1), (char*)dr,' b'! \t\t (app-destroy_count i) sizeof(destroyrec)' b');' b'xtphase2destroy(w);' b'}' b'else b'i++;' b'}' b'}' b'}' b'' b'' b'----------------------------------------------------------------------' b'' b'although some books demonstrate that the current implementation of xt' b'happens to call callback procedures in the order in which they are registered,' b'the specification does not guarantee such a sequence, and supplemental' b'authoritative documents (i.e. the asente/swick volume) do say that the order is' b'undefined. because the callback list can be manipulated by both the widget and' b'the application, xt cannot guarantee the order of execution.' b'in general, the callback procedures should be thought of as operating' b'independently of one another and should not depend on side-effects of other' b'callbacks operating; if a seqence is needed, then the single callback to be' b'registered can explicitly call other functions necessary.' b'' b'' b'----------------------------------------------------------------------' b'' b'xtdestroywidget() operates in two passes, in order to avoid leaving' b'dangling data structures; the function-call marks the widget, which is not' b'actually destroyed until your program returns to its event-loop.' b'' b'----------------------------------------------------------------------' b'' b'it is possible to have code which looks like this trivial callback,' b'which has a clear flow of control. the calls to askuser() block until answer' b'is set to one of the valid values. if it is not a "yes" answer, the code drops' b'out of the callback and back to an event-processing loop:' b'' b'void quit(widget w, xtpointer client, xtpointer call)' b'{' b'int answer;' b'answer askuser(w, "really quit?");' b'if (ret_yes answer)' b'{' b'answer askuser(w, "are you really positive?");' b'if (ret_yes answer)' b'exit(0);' b'}' b'}' b'' b'a more realistic example might ask whether to create a file or whether' b'to overwrite it.' b'this is accomplished by entering a second event-processing loop and' b'waiting until the user answers the question; the answer is returned to the' b'calling function. that function askuser() looks something like this, where the' b'motif can be replaced with widget-set-specific code to create some sort of' b'dialog-box displaying the question string and buttons for "ok", "cancel" and' b'"help" or equivalents:' b'' b'int askuser(w, string)' b'widget w;' b'char *string;' b'{' b'int answer=ret_none;\t/* some not-used marker b'widget dialog;\t\t\t/* could cache&carry, but b'arg args[3];' b'int n b'xtappcontext context;' b'' b'n=0;' b'xtsetarg(args[n], xmnmessagestring, xmstringcreateltor(string,' b'xmstring_default_charset)); n++;' b'xtsetarg(args[n], xmndialogstyle, xmdialog_application_modal); n++;' b'dialog xmcreatequestiondialog(xtparent(w), string, args, n);' b'xtaddcallback(dialog, xmnokcallback, response, &answer);' b'xtaddcallback(dialog, xmncancelcallback, response, &answer);' b'xtaddcallback(dialog, xmnhelpcallback, response, &answer);' b'xtmanagechild(dialog);' b'' b'context xtwidgettoapplicationcontext (w);' b'while (answer ret_none xtapppending(context)) b'xtappprocessevent (context, xtimall);' b'}' b'xtdestroywidget(dialog); blow away the dialog box and shell b'return answer;' b'}' b'' b'the dialog supports three buttons, which are set to call the same' b'function when tickled by the user. the variable answer is set when the user' b'finally selects one of those choices:' b'' b'void response(w, client, call)' b'widget w;' b'xtpointer client;' b'xtpointer call;' b'{' b'int *answer (int client;' b'xmanycallbackstruct *reason (xmanycallbackstruct call;' b'switch (reason-reason) b'case xmcr_ok:' b'*answer ret_yes;\t/* some #define value b'break;' b'case xmcr_cancel:' b'*answer ret_no;' b'break;' b'case xmcr_help:' b'*answer ret_help;' b'break;' b'default:' b'return;' b'}' b'}' b'' b'and the code unwraps back to the point at which an answer was needed and' b'continues from there.' b'' b'widgetwrap library. b'' b'----------------------------------------------------------------------' b'i have a widget id and need to know what the name of that widget is.' b'' b'users of r4 and later are best off using the xtname() function, which' b'will work on both widgets and non-widget objects.' b'' b'if you are still using r3, you can use this simple bit of code to do' b"what you want. note that it depends on the widget's internal data structures" b'and is not necessarily portable to future versions of xt, including r4.' b'' b'#include <x11/corep.h' b'#include <x11/xresource.h' b'string xtname (widget)' b'widget widget;\t/* will work with non-widget objects b'{' b'return xrmnametostring(widget-core.xrm_name);' b'}' b'' b'' b'----------------------------------------------------------------------' b"i'm doing this in order to get a window into which i can do xlib graphics" b'within my xt-based program:' b'' b' canvas xtcreatemanagedwidget ...,widgetclass,...) drawing area b' b' window xtwindow(canvas);\t/* get the window associated with the widget b' b' xdrawline (...,window,...);\t/* produces error b'' b'the window associated with the widget is created as a part of the' b'realization of the widget. using a window id of null ("no window") could' b'create the error that you describe. it is necessary to call xtrealizewidget()' b'before attempting to use the window associated with a widget.' b'note that the window will be created after the xtrealizewidget() call,' b'but that the server may not have actually mapped it yet, so you should also' b'wait for an expose event on the window before drawing into it.' b'' b'----------------------------------------------------------------------' b'' b'the badmatch error can occur if the specified rectangle goes off the edge of' b"the screen. if you don't want to catch the error and deal with it, you can take" b'the following steps to avoid the error:' b'' b'1) make a pixmap the same size as the rectangle you want to capture.' b'2) clear the pixmap to background using xfillrectangle.' b'3) use xcopyarea to copy the window to the pixmap.' b'4) if you get a noexpose event, the copy was clean. use xgetimage to grab the' b'image from the pixmap.' b"5) if you get one or more graphicsexpose events, the copy wasn't clean, and" b'the x/y/width/height members of the graphicsexpose event structures tell you' b"the parts of the pixmap which aren't good." b'6) get rid of the pixmap; it probably takes a lot of memory.' b'' b'' b'----------------------------------------------------------------------' b'' b'a number of programs offer x modes but otherwise run in a straight' b'character-only mode. the easiest way for an application to determine that it is' b'running on an x display is to attempt to open a connection to the x server:' b'' b'display xopendisplay(display_name);' b'if (display)' b'{ do x stuff b'else' b'{ do curses or something else b'where display_name is either the string specified on the command-line following' b'-display, by convention, or otherwise is (char*)null [in which case' b'xopendisplay uses the value of $display, if set].' b'' b'this is superior to simply checking for the existence a -display command-line' b'argument or checking for $display set in the environment, neither of which is' b'adequate. b'' b'----------------------------------------------------------------------' b'is it necessary to call xdefinecursor() for every window in my application?' b'' b'the easiest thing to do is to create a single inputonly window that is' b'as large as the largest possible screen; make it a child of your toplevel' b"window and it will be clipped to that window, so it won't affect any other" b'application. (it needs to be as big as the largest possible screen in case the' b'user enlarges the window while it is busy or moves elsewhere within a virtual' b'desktop.) substitute "toplevel" with your top-most widget here (similar code' b'should work for xlib-only applications; just use your top window):' b'' b'unsigned long valuemask;' b'xsetwindowattributes attributes;' b'' b'/* ignore device events while the busy cursor is displayed. b'valuemask cwdontpropagate cwcursor;' b'attributes.do_not_propagate_mask (keypressmask keyreleasemask b'buttonpressmask buttonreleasemask pointermotionmask);' b'attributes.cursor xcreatefontcursor(xtdisplay(toplevel), xc_watch);' b'' b'/* the window will be as big as the display screen, and clipped by' b'its own parent window, so we never have to worry about resizing b'xcreatewindow(xtdisplay(toplevel), xtwindow(toplevel), b'65535, (unsigned int) inputonly,' b'copyfromparent, valuemask, &attributes);' b'' b'where the maximum size above could be replaced by the real size of the screen,' b'particularly to avoid servers which have problems with windows larger than' b'32767.' b'' b'when you want to use this busy cursor, map and raise this window; to go back to' b'normal, unmap it. this will automatically keep you from getting extra mouse' b'events; depending on precisely how the window manager works, it may or may not' b'have a similar effect on keystrokes as well.' b'' b'in addition, note also that most of the xaw widgets support an xtncursor' b'resource which can be temporarily reset, should you merely wish to change the' b'cursor without blocking pointer events.' b'' b'' b'----------------------------------------------------------------------' b'' b'an x-based application which spawns off other unix processes which' b'continue to run after it is closed typically does not vanish until all of its' b'children are terminated; the children inherit from the parent the open x' b'connection to the display.' b'what you need to do is fork; then, immediately, in the child process,' b'close (connectionnumber(xtdisplay(widget)));' b'to close the file-descriptor in the display information. after this do your' b'exec. you will then be able to exit the parent.' b"alternatively, before exec'ing make this call, which causes the file" b'descriptor to be closed on exec.' b'(void) fcntl(connectionnumber(xdisplay), f_setfd, b'' b'' b'----------------------------------------------------------------------' b'' b'no. xlib and xt have no mutual exclusion for protecting critical' b'sections. if your signal handler makes such a call at the wrong time (which' b'might be while the function you are calling is already executing), it can leave' b'the library in an inconsistent state. note that the ansi c standard points' b'out that behavior of a signal handler is undefined if the signal handler calls' b'any function other than signal() itself, so this is not a problem specific to' b'xlib and xt; the posix specification mentions other functions which may be' b'called safely but it may not be assumed that these functions are called by' b'xlib or xt functions.' b'you can work around the problem by setting a flag in the interrupt' b'handler and later checking it with a work procedure or a timer event which' b'has previously been added.' b'' b"note: the article in the x journal and the example in o'reilly" b'volume are in error.' b'' b'' b'----------------------------------------------------------------------' b'' b'you may see these errors if you issue xlib requests from an xlib error' b'handler, or, more likely, if you make calls which generate x requests to xt or' b"xlib from a signal handler, which you shouldn't be doing in any case." b'' b'----------------------------------------------------------------------' b'' b"it's very common to need to write an xt program that can accept input" b'both from a user via the x connection and from some other file descriptor, but' b'which operates efficiently and without blocking on either the x connection or' b'the other file descriptor.' b'a solution is use xtappaddinput(). after you open your file descriptor,' b'use xtappaddinput() to register an input handler. the input handler will be' b'called every time there is something on the file descriptor requiring your' b"program's attention. write the input handler like you would any other xt" b'callback, so it does its work quickly and returns. it is important to use only' b'non-blocking i/o system calls in your input handlers.' b'most input handlers read the file descriptor, although you can have an' b'input handler write or handle exception conditions if you wish.' b'be careful when you register an input handler to read from a disk file.' b"you will find that the function is called even when there isn't input pending." b'xtappaddinput() is actually working as it is supposed to. the input handler is' b'called whenever the file descriptor is ready to be read, not only when there is' b'new data to be read. a disk file (unlike a pipe or socket) is almost always' b'ready to be read, however, if only because you can spin back to the beginning' b"and read data you've read before. the result is that your function will almost" b'always be called every time around xtappmainloop(). there is a way to get the' b'type of interaction you are expecting; add this line to the beginning of your' b'function to test whether there is new data:' b'if (ioctl(fd, fionread, &n) n return;' b'but, because this is called frequently, your application is effectively in a' b'busy-wait; you may be better off not using xtappaddinput() and instead setting' b'a timer and in the timer procedure checking the file for input.' b'' b'' b'----------------------------------------------------------------------' b'' b"you can do this using xsendevent(); it's likely that you're not setting" b'the window field in the event, which xt needs in order to match to the widget' b'which should receive the event.' b"if you're sending events to your own application, then you can use" b'xtdispatchevent() instead. this is more efficient than xsendevent() in that you' b'avoid a round-trip to the server.' b'depending on how well the widget was written, you may be able to call' b'its action procedures in order to get the effects you want.' b'' b'' b'----------------------------------------------------------------------' b'' b' b' the_window xcreatesimplewindow(the_display,' b' root_window,size_hints.x,size_hints.y,' b' size_hints.width,size_hints.height,border_width,' b' blackpixel(the_display,the_screen),' b' whitepixel(the_display,the_screen));' b' b' xselectinput(the_display,the_window,exposuremask|buttonpressmask|' b' \tbuttonreleasemask);' b' xmapwindow(the_display,the_window);' b' b' xdrawline(the_display,the_window,the_gc,5,5,100,100);' b' b'' b'you are right to map the window before drawing into it. however, the' b'window is not ready to be drawn into until it actually appears on the screen b'until your application receives an expose event. drawing done before that will' b"generally not appear. you'll see code like this in many programs; this code" b'would appear after window was created and mapped:' b'while (!done)' b'{' b'xnextevent(the_display,&the_event);' b'switch (the_event.type) b'case expose:\t on expose events, redraw b'xdrawline(the_display,the_window,the_gc,5,5,100,100);' b'break;' b'...' b'}' b'}' b'' b"note that there is a second problem: some xlib implementations don't" b'set up the default graphics context to have correct foreground/background' b'colors, so this program could previously include this code:' b'...' b'the_gc_values.foreground=blackpixel(the_display,the_screen);\t/* e.g. b'the_gc_values.background=whitepixel(the_display,the_screen);\t/* e.g. b'the_gc xcreategc(the_display,the_window,' b'gcforeground|gcbackground,&the_gc_values);' b'...' b'' b'note: the code uses blackpixel and whitepixel to avoid assuming that is' b'black and is white or vice-versa. the relationship between pixels and b'and the colors black and white is implementation-dependent. they may be' b'reversed, or they may not even correspond to black and white at all.' b'' b'also note that actually using blackpixel and whitepixel is usually the wrong' b"thing to do in a finished program, as it ignores the user's preference for" b'foreground and background.' b'' b'and also note that you can run into the same situation in an xt-based program' b'if you draw into the xtwindow(w) right after it has been realized; it may' b'not yet have appeared.' b'' b'----------------------------------------------------------------------' b'' b"the 'screen' is an xlib structure which includes the information about" b'one of the monitors or virtual monitors which a single x display supports. a' b'server can support several independent screens. they are numbered unix:0.0,' b"unix:0.1, unix:0.2, etc; the 'screen' or 'screen_number' is the second digit b'the which can be thought of as an index into the array of available' b'screens on this particular display connection.' b'the macros which you can use to obtain information about the particular' b'screen on which your application is running typically have two forms one' b'which takes a screen and one with takes both the display and the screen_number.' b'in xt-based programs, you typically use xtscreen(widget) to determine' b'the screen on which your application is running, if it uses a single screen.' b'(part of the confusion may arise from the fact that some of the macros' b'which return characteristics of the screen have "display" in the names b'xdisplaywidth, xdisplayheight, etc.)' b'' b'----------------------------------------------------------------------' b'' b'the x11r4/5 header files are compatible with c++. the motif header' b'files are usable as is inside extern "c" however, the definition of' b'string in intrinsic.h can conflict with the libg++ or other string class and' b'needs to be worked around.' b'' b'some other projects which can help:' b'wwl, a set of c++ classes by jean-daniel fekete to wrap x toolkit' b'widgets, available via anonymous ftp from export.lcs.mit.edu as' b'contrib/wwl-1.2.tar.z or lri.lri.fr as pub/wwl-1.2.tar.z.' b'it works by building a set of c++ classes in parallel to the class tree of the' b'widgets.' b'the c++ interviews toolkit is obtainable via anonymous ftp from' b'interviews.stanford.edu. interviews uses a box/glue model similar to that of' b'tex for constructing user interfaces and supports multiple looks on the user' b'interfaces. some of its sample applications include a wysiwig document editor' b'(doc), a macdraw-like drawing program (idraw) and an interface builder' b'(ibuild).' b'things, a class library written at the rome air force base by the' b'strategic air command, available as freeware on archive sites.' b'' b'motif++ is a public-domain library that defines c++ class wrappers for' b'motif it adds an "application" class for, e.g., initializing x, and also' b'integrates wcl and the xbae widget set. this work was developed by ronald van' b'of lowell graphics research laboratory. the current sources are available from' b'decuac.dec.com as /pub/x11/motif++.21.jul.92.tar.z.' b'' b'the source code examples for doug young\'s "object-oriented programming' b'with c++ and osf/motif" [isbn do not include "widget wrappers"' b'but do include a set of classes that encapsulates higher-level facilities' b'commonly needed by motif- or other xt-based applications; check export in' b'~ftp/contrib/young.c++.tar.z.' b'rogue wave offers "view.h++" for c++ programmers using motif; info:' b'1-800-487-3217 or b'a product called "commonview" by glockenspiel ltd, ireland b'apparently is a c++-based toolkit for multiple window systems, including pm,' b'windows, and x/motif.' b'xv++ is sold by qualix fax it implements an' b"interface from the gil files that sun's openwindows developers guide b'produces to xview wrapper classes in c++.' b'' b'uit is a set of c++ classes embedding the xview toolkit; it is intended' b"for use with sun's openwindows developers guide builder tool. sources are" b'on export.mit.edu.au as uit.tar.z. version was released b'' b'also of likely use is objectcenter (saber-c++). and a reasonable' b"alternative to all of the above is parcplace's (formerly solbourne's) object" b'interface.' b'' b'' b'----------------------------------------------------------------------' b'' b'versions of the clx lisp bindings are part of the x11 core source' b'distributions. a version of clx is on the r5 tape version b'is on export.lcs.mit.edu in /contrib/clx.r5.02.tar.z.' b'' b'the saic ada-x11 bindings are through anonymous ftp in /pub from' b'stars.rosslyn.unisys.com b'there is an x/ada study team sponsored by nasa jsc, which apparently is' b'gnu smalltalk has a beta native smalltalk binding to x called stix (by' b'documentation is sparse outside the smalltalk code itself. the sources are' b'available as /pub/gnu/smalltalk-1.1.1.tar.z on prep.ai.mit.edu or' b'ugle.unit.no b'prolog bindings (called "xwip") written by ted kim at ucla while' b'supported in part by darpa are available by anonymous ftp from' b'export.lcs.mit.edu:contrib/xwip.tar.z or ftp.cs.ucla.edu:pub/xwip.tar.z.' b'these prolog language bindings depend on having a quintus-type foreign function' b'interface in your prolog. the developer has gotten it to work with quintus and' b'scheme bindings to xlib, osf/motif, and xaw are part of the elk' b'distribution; version 1.5a on export obsoletes the version on the r5 contrib' b'tape.' b'x-scm, a bolt-on accessory for aubrey jaffer\'s "scm" scheme interpreter' b'that provides an interface to xlib, motif, and openlook, is now available via' b'ftp from altdorf.ai.mit.edu:archive/scm/xscm1.05.tar.z and' b'nexus.yorku.ca:pub/scheme/new/xscm1.05.tar.z.' b'' b'ada bindings to motif, explicitly, will eventually be made available by' b'the jet propulsion laboratories, probably through the normal electronic' b'who may respond as time permits.' b'adamotif is a complete binding to x and motif for the ada language, for' b'many common systems; it is based in part upon the saic/unisys bindings and also' b'includes a uil to ada translator. info: systems engineering research' b'' b'also: the mit consortium, although not involved in producing ada' b'bindings for x, maintains a partial listing of people involved in x and ada;' b'' b'----------------------------------------------------------------------' b'' b'no. once set, the background pixel or pixmap of a window cannot be' b're-read by clients. the reason for this is that a client can create a pixmap,' b'set it to be the background pixmap of a window, and then free the pixmap. the' b"window keeps this background, but the pixmap itself is destroyed. if you're" b'sure a window has a background pixel (not a pixmap), you can use xcleararea()' b'to clear a region to the background color and then use xgetimage() to read' b'back that pixel. however, this action alters the contents of the window, and' b'it suffers from race conditions with exposures. [courtesy dave lemke of ncd' b'and stuart marks of sun]' b'' b'note that the same applies to the border pixel/pixmap. this is a' b'(mis)feature of the protocol which allows the server is free to manipulate the' b'pixel/pixmap however it wants. by not requiring the server to keep the' b'original pixel or pixmap, some (potentially a lot of) space can be saved.' b'[courtesy jim fulton, mit x consortium]' b'' b'----------------------------------------------------------------------' b'' b'a completely transparent window is easy to get use an inputonly' b'window. in order to create a window which is *mostly* transparent, you have' b'several choices:' b'- the shape extension first released with x11r4 offers an easy way to' b'make non-rectangular windows, so you can set the shape of the window to fit the' b'areas where the window should be nontransparent; however, not all servers' b'support the extension.' b'- a machine-specific method of implementing transparent windows for' b'particular servers is to use an overlay plane supported by the hardware. note' b'that there is no x notion of a "transparent color index".' b'- a generally portable solution is to use a large number of tiny' b'windows, but this makes operating on the application as a unit difficult.' b'- a final answer is to consider whether you really need a transparent' b'window or if you would be satisfied with being able to overlay your application' b'window with information; if so, you can draw into separate bitplanes in colors' b'that will appear properly.' b'' b'the x journal for a more complete answer, including code samples for this' b'last option]' b'' b'----------------------------------------------------------------------' b'' b'when using gxxor you may expect that drawing with a value of black on a' b'background of black, for example, should produce white. however, the drawing' b'operation does not work on rgb values but on colormap indices. the color that' b'the resulting colormap index actually points to is undefined and visually' b'random unless you have actually filled it in yourself. [on many x servers black' b'and white often or programs taking advantage of this mathematical' b'coincidence will break.]' b'if you want to be combining colors with gxxor, then you should be' b'allocating a number of your own color cells and filling them with your chosen' b'pre-computed values.' b'if you want to use gxxor simply to switch between two colors, then you' b'can take the shortcut of setting the background color in the gc (graphics' b'context) to and the foreground color to a value such that when it draws over' b'red, say, the result is blue, and when it draws over blue the result is red.' b'this foreground value is itself the xor of the colormap indices of red and' b'blue.' b'' b'' b'----------------------------------------------------------------------' b'' b"make sure you're using bits and not the red, green, and blue" b'fields of an xcolor structure are scaled so that is nothing and is' b'full-blast. if you forget to scale (using, for example, for each color)' b'the xalloccolor function will perform correctly but the resulting color is' b'usually black.' b'' b'' b'----------------------------------------------------------------------' b'i have an image-processing program which uses xgetrgbcolormap() to get the' b"standard colormap, but it doesn't work." b'' b'xgetrgbcolormap() when used with the property xa_rgb_default_map does' b'not create a standard colormap it just returns one if one already exists.' b'use xstdcmap or do what it does in order to create the standard colormap first.' b'' b'' b'----------------------------------------------------------------------' b'' b'the initial contents of pixmaps are undefined. this means that most' b'servers will allocate the memory and leave around whatever happens to be there' b'-- which is usually garbage. you probably want to clear the pixmap first using' b'xfillrectangle() with a function of gxcopy and a foreground pixel of whatever' b'color you want as your background (or 0l if you are using the pixmap as a' b'mask). [courtesy dave lemke of ncd and stuart marks of sun]' b'' b'----------------------------------------------------------------------' b'my program has the id of a window on a remote display. i want to check whether' b'the window exists before doing anything with it.' b'' b"because x is asynchronous, there isn't a guarantee that the window" b'would still exist between the time that you got the id and the time you sent an' b'event to the window or otherwise manipulated it. what you should do is send the' b'event without checking, but install an error handler to catch any badwindow' b'errors, which would indicate that the window no longer exists. this scheme will' b'work except on the [rare] occasion that the original window has been destroyed' b'and its id reallocated to another window.' b'' b'' b'----------------------------------------------------------------------' b'' b'yes. the x server assigns ids to windows and other resources (actually,' b'the server assigns some bits, the client others), and any application that' b'knows the id can manipulate the resource [almost any x server resource, except' b'for gcs and private color cells, can be shared].' b'the problem you face is how to disseminate the window id to multiple' b'applications. a simple way to handle this (and which solves the problem of the' b"applications' running on different machines) is in the first application to" b'create a specially-named property on the root-window and put the window id into' b'it. the second application then retrieves the property, whose name it also' b'knows, and then can draw whatever it wants into the window.' b'[note: this scheme works iff there is only one instance of the first' b'application running, and the scheme is subject to the limitations mentioned' b'in the question about using window ids on remote displays.]' b'note also that you will still need to coordinate any higher-level' b'cooperation among your applications.' b'note also that two processes can share a window but should not try to' b'use the same server connection. if one process is a child of the other, it' b'should close down the connection to the server and open its own connection.' b'' b'' b'----------------------------------------------------------------------' b'' b'a number of applications, including xwd, xwininfo, and xsetroot, do not' b'handle the virtual root window which tvtwm and swm use; they typically return' b'the wrong child of root. a general solution is to add this code or to use it in' b'your own application where you would normally use rootwindow(dpy,screen):' b'' b'/* function name: getvroot' b"* description: gets the root window, even if it's a virtual root" b'* arguments: the display and the screen' b'* returns: the root window for the client' b'*/' b'#include <x11/xatom.h' b'window getvroot(dpy, scr)' b'display *dpy;' b'int scr;' b'{' b'window rootreturn, parentreturn, *children;' b'unsigned int numchildren;' b'window root rootwindow(dpy, scr);' b'atom __swm_vroot none;' b'int i;' b'' b'__swm_vroot xinternatom(dpy, "__swm_vroot", false);' b'xquerytree(dpy, root, &rootreturn, &parentreturn, &children, &numchildren);' b'for (i i numchildren; i++) b'atom actual_type;' b'int actual_format;' b'long nitems, bytesafter;' b'window *newroot null;' b'' b'if (xgetwindowproperty(dpy, children[i], __swm_vroot, b'false, xa_window, &actual_type, &actual_format, &nitems,' b'&bytesafter, (unsigned char &newroot) success newroot) b'root *newroot;' b'break;' b'}' b'}' b'' b'return root;' b'}' b'' b'version of xsetroot distributed with tvtwm. b'' b'a header file by andreas stolcke of icsi on export.lcs.mit.edu:contrib/vroot.h' b'functions similarly by providing macros for rootwindow and defaultrootwindow;' b'code can include this header file first to run properly in the presence of a' b'virtual desktop.' b'' b'----------------------------------------------------------------------' b'' b'resizing the window is done through the window manager; window managers' b'can pay attention to the size hints your application places on the window, but' b'there is no guarantee that the window manager will listen. you can try setting' b'the minimum and maximum size hints to your target size and hope for the best.' b'[1/91]' b'' b'----------------------------------------------------------------------' b'' b"it's rather antisocial for an application to constantly raise itself" b"[e.g. by tracking visibilitynotify events] so that it isn't overlapped b'imagine the conflict between two such programs running.' b'the only sure way to have your window appear on the top of the stack' b'is to make the window override-redirect; this means that you are temporarily' b'assuming window-management duties while the window is up, so you want to do' b'this infrequently and then only for short periods of time (e.g. for popup' b'menus or other short parameter-setting windows).' b'' b'' b'----------------------------------------------------------------------' b'' b"there is no easy way. unless you're willing to depend on some sort of" b'extension (as yet non-existent), you have to arrange for the blinking yourself,' b'either by redrawing the contents periodically or, if possible, by playing games' b'with the colormap and changing the color of the contents.' b'' b'' b'----------------------------------------------------------------------' b'' b'users of xt have the support of the translation manager to help' b'get notification of double-clicking.' b'there is no good way to get only a double-click in xlib, because the' b'protocol does not provide enough support to do double-clicks. you have to do' b'client-side timeouts, unless the single-click action is such that you can defer' b'actually taking it until you next see an event from the server. thus, you' b'have to do timeouts, which means system-dependent code. on most unixish' b'implementations, you can use xconnectionnumber to get the file descriptor of' b'the x connection and then use select() or something similar on that.' b'note that many user-interface references suggest that a double-click' b'be used to extend the action indicated by a single-click; if this is the case' b'in your interface then you can execute the first action and as a compromise' b'check the timestamp on the second event to determine whether it, too, should' b'be the single-click action or the double-click action.' b'' b'' b'----------------------------------------------------------------------' b'' b'xlib intentionally does not provide such sophisticated graphics' b'capabilities, leaving them up to server-extensions or clients-side graphics' b'libraries.' b'your only choice, if you want to stay within the core x protocol, is to' b'render the text into a pixmap, read it back via xgetimage(), rotate it "by' b'hand" with whatever matrices you want, and put it back to the server via' b'xputimage(); more specifically:' b'1) create a bitmap b and write your text to it.' b'2) create an xybitmap image i from b (via xgetimage).' b'3) create an xybitmap image i2 big enough to handle the transformation.' b'4) for each x,y in i2, i2(x,y) i(a,b) where' b'a x cos(theta) y sin(theta)' b'b x sin(theta) y cos(theta)' b'5) render i2' b'note that you should be careful how you implement this not to lose' b'bits; an algorithm based on shear transformations may in fact be better.' b'the high-level server-extensions and graphics packages available for x' b'also permit rendering of rotated text: display postscript, pex, phigs, and gks,' b'although most are not capable of arbitrary rotation and probably do not use the' b'same fonts that would be found on a printer.' b'in addition, if you have enough access to the server to install a font' b'on it, you can create a font which consists of letters rotated at some' b'predefined angle. your application can then itself figure out placement of each' b'glyph.' b'' b'' b'interviews (c++ ui toolkit, in the x contrib software) has support for' b'rendering rotated fonts in x. it could be one source of example code.' b'another possibility is to use the hershey fonts; they are' b'stroke-rendered and can be used by x by converting them into xdrawline' b'' b'(posted to comp.sources.x july paints a rotated font by implementing' b'the method above and by using an outline (hershey) font.' b'set of functions to facilitate the writing of text at any angle. version b'was recently released to alt.sources and comp.sources.misc it is also' b'on export as contrib/xvertext.3.0.shar.z.' b'' b"o'reilly's x resource volume includes information from hp about" b'modifications to the x fonts server which provide for rotated and scaled text.' b'' b'----------------------------------------------------------------------' b'' b'there are places in the x toolkit, in applications, and in the x' b'protocol that define and use string names. the context is such that conflicts' b'are possible if different components use the same name for different things.' b'the mit x consortium maintains a registry of names in these domains:' b'orgainization names, selection names, selection targets, resource types,' b'application classes, and class extension record types; and several others.' b'the list as of is in the directory mit/doc/registry on the r5' b'tape; it is also available by sending "send docs registry" to the xstuff mail' b'server.' b'to register names (first come, first served) or to ask questions send' b'confirmation.' b'' b'[11/90; condensed from asente/swick appendix h]' b'----------------------------------------------------------------------' b'' b'' b'' b'"just the faqs, ma\'am." joe friday' b'--' b'david b. lewis\t\ttemporarily at but not speaking for visual, inc.' 