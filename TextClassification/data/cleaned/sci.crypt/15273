b'' b'' b'i heard about this solution, and it sounded good. then i heard that folks' b'were experiencing times of seconds to run this, on' b"reasonably-configured workstations. i'm not willing to add that much delay" b"to someone's login process. my approach (etherfind|compress, skip 10k) takes" b"a second or two to run. i'm considering writing the be-all and end-all of" b'solutions, that launches the md5, and simultaneously tries to suck bits off' b"the net, and if the net should be sitting __so__ idle that it can't get 10k" b'after compression before md5 finishes, use the md5. this way i could have' b'guaranteed good bits, and a deterministic upper bound on login time, and' b'still have the common case of login take only a couple of extra seconds.' b'' b'' b'53 seconds to hash 20m of core (i bet i know who the source of your' b"information is!). no, it's not acceptable if it's part of your login" b'process. but if you are going to use network traffic as the source of' b'pseudo-random information, do the right thing and pass it through a' b'cryptographic hash function, not a compressor. aside from the fact' b'that it will run faster, it will give better results (think of a' b'cryptographic hash as a function that "distills" randomness).' b'something along the lines of' b'etherfind -t -x -n dd bs=1k count=10 2/dev/null md5' b'should do the trick. -t gives you timestamps, and the lack of -u makes' b'sure that dd does not get ten lines as opposed to ten k. the above' b'takes a couple of seconds on a lightly-loaded ethernet.' b'' b'-bennett' b'' b'/ji' b'' 