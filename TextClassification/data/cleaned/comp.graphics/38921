b'' b'' b'david gorgen writes:' b'' b" i'm asking for help on a sticky problem involving unreasonably low" b" apparent precision in z-buffering, that i've encountered in different" b" pex implementations. i can't find any discussion of this problem in any" b" resources i can lay hands on (e.g. the comp.windows.x.pex faq, gaskins's" b" _pexlib_programming_manual_, vendors' documentation)." b'' b' b'' b' the problem to be solved is to eliminate or minimize "stitching"' b' artifacts resulting from the use of z-buffering with polylines that are' b' coplanar with filled areas. the interpolated z values along a line will' b' differ slightly, due to roundoff error, from the interpolated z values' b' across an area, even when the endpoints of the line are coincident with' b" vertices of the area. because of this, it's a tossup whether the" b' z-buffer will allow the line pixels or the area pixels to be displayed.' b' visually, the result tends to be a dashed-line effect even though the' b' line is supposed to be solid.' b'' b' using the pexlib api, my approach to a solution is to use two slightly' b' different pex view mapping transforms, in two view table entries, one' b' for the areas and one for the lines. the pex structures or immediate-' b' mode output must be organized so that one view table index is always in' b' effect for areas, and the other is always in effect for lines. the' b' result is a slight shift in npc z coordinates for the lines, so as to' b' attempt to bias the tossup situations in favor of the lines.' b'' b' this shift is effected by moving the front and back clipping planes used' b' in the pexlib view table entry for lines just a hair "backwards" (i.e.' b' smaller vrc z coordinates), compared to their positions in the view' b' table entry used for areas. this means that when a point is transformed' b' to npc, its z value will be slightly bigger if it comes from a line than' b' if it comes from an area, thus accomplishing the desired bias.' b'' b' i would expect the z roundoff errors which cause the problem to amount' b' to a few units at most, out of the entire dynamic range of the z-buffer,' b' typically from to if not (i.e. or bit z-buffers).' b' therefore, it seems that a tiny fraction of the range of z in vrc' b' between the front and back clip planes ought to suffice to reliably fix' b' the stitching.' b'' b' but in fact, experience shows that the shift has to be as much as b" to of the range. (empirically, it's worst when the npc z" b' component of the slope of the surface is high, i.e. when it appears more' b" or less edge-on to the viewer.) it's as if only or bits of the" b' z-buffer have any dependable meaning! this amount is so great that one' b' problem is replaced by another: sometimes the polylines "show through"' b' areas which they are supposed to lie behind.' b'' b" i've observed the problem on both hewlett-packard and digital" b' workstation pex servers, to approximately the same degree. the test' b' program demonstrates the problem on an mit pexlib 5.x implementation;' b' this version is known to compile and run on an hp-ux system with pex' b' b'' b' open questions:' b' why does this happen?' b' am i configuring the pex view table wrongly?' b' is there a systematic difference in z interpolation for lines' b' as opposed to areas (e.g. pixel centers versus corners) which' b' could be corrected for?' b' are pex implementors wantonly discarding z precision in their' b' interpolators?' b' something else?' b' what to do about it?' b' can i fix my use of the view table to allow better precision' b' in z-buffered hlhsr?' b' is there another approach i can take to remove the stitching' b' artifacts?' b' am i just out of luck?' b'' b'' b'we here at ibm have the same problem with our workstations. i was also' b'shocked when i first realized that you have to offset lines from fills by' b'about bits (assuming bit z buffer). this seems huge, but is only' b"1/256 of the dynamic range. in those terms it doesn't seem so bad. what" b'is happening is that the interpolation in z is not totally linear, due' b'mainly to roundoff, i believe. so the polygon is not planar in z, but is' b'more like a ruffles potato chip. ditto with lines. when you start/end at' b'different x/y values, the "ridges" are out of phase, resulting in the' b'stitch effect. you have the same problem if you try to draw polygon' b'right on top of another, but with different vertices. you will likely see' b'a smeared effect where they overlap.' b'example:' b'try polygon b'polygon b'' b'your implementation is correct. in fact, we do a similar trick when' b'rendering primitives that have lines and polygons such as nurbs surfaces' b'with isoparametric lines. without the trick, the lines appear stitched, as' b'you say. when the application draws lines/polygons independently, the' b'system does not have the smarts to automatically do the z shifting, so the' b'application must do it. this is what you have discovered and are doing.' b'bravo!' b'' b"(note to ibm'ers: the information given here has been previously disclosed" b"through proper channels so i'm not giving away any new unpublished info.)" b'' b'--' b'ibm advanced workstations and systems graphics systems' b'austin tx' b'* views and opinions expressed herein are not necessarily those of ibm corp. 