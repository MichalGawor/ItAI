b'' b' hello, i know that this has been discussed before. but at the time' b"i didn't need to teselate a sphere. so if any kind soul has the code" b'or the alg, that was finally decided upon as the best (as i recall it' b'was a nice, iterative subdivision meathod), i would be very' b'appreciative.' b'' b'here is one by andrew "graphics gems" glassner that i got from a' b'collegue of mine. i think i fiddled with it a little bit to make it' b'deal with whatever bizarre problem i was working on at the time but it' b'is known to work.' b'' b'spl' b'- b'/* spheres' b'asg feb b'spl thu mar est b'*/' b'#include <stdio.h' b'#include <math.h' b'' b'#define pi b'' b'struct point_struct b'double x, y, z;' b'};' b'' b'static double radius;' b'static double xorg;' b'static double yorg;' b'static double zorg;' b'' b'do_sphere( r, freq, x, y, z b'' b'double r;' b'int freq;' b'double x;' b'double y;' b'double z;' b'' b'{' b'' b'int pole;' b'double northy, southy, poley;' b'double rtheta, rtheta2, ntheta, ntheta2, magicangle;' b'double theta, thetastart, thisy, den, t;' b'struct point_node *pnp;' b'struct point_struct p1, p2, p3, p4, n1, n2, n3, n4, pt;' b'' b'radius r;' b'xorg x;' b'yorg y;' b'zorg z;' b'' b'/* north pole b'' b'magicangle 30.0*pi/180.0;' b'northy radius*sin(magicangle);' b'southy -radius*sin(magicangle);' b'for (pole=0; pole<2; pole++) b'' b'if (pole==0) b'' b'poley=radius;' b'thisy=northy;' b'thetastart=0.0;' b'' b'}' b'else b'' b'poley= -radius;' b'thisy=southy;' b'thetastart=36.0;' b'' b'}' b'for theta thetastart; theta theta b'' b'rtheta theta*pi/180.0;' b'rtheta2 (theta+60.0)*pi/180.0;' b'p1.x b'p1.y poley;' b'p1.z b'p2.x radius*cos(rtheta);' b'p2.y thisy;' b'p2.z radius*sin(rtheta);' b'p3.x radius*cos(rtheta2);' b'p3.y thisy;' b'p3.z radius*sin(rtheta2);' b'' b'if (pole==0) b'' b'/* make ring go the other way so normals are right b'' b'pt.x p3.x;' b'pt.y p3.y;' b'pt.z p3.z;' b'p3.x p2.x;' b'p3.y p2.y;' b'p3.z p2.z;' b'p2.x pt.x;' b'p2.y pt.y;' b'p2.z pt.z;' b'' b'}' b'' b'den (p1.x*p1.x)+(p1.y*p1.y)+(p1.z*p1.z);' b'den sqrt(den);' b'' b'if (den b'' b't radius den;' b'p1.x t;' b'p1.y t;' b'p1.z t;' b'' b'}' b'' b'den (p2.x*p2.x)+(p2.y*p2.y)+(p2.z*p2.z);' b'den sqrt(den);' b'' b'if (den b'' b't radius den;' b'p2.x t;' b'p2.y t;' b'p2.z t;' b'' b'}' b'' b'den (p3.x*p3.x)+(p3.y*p3.y)+(p3.z*p3.z);' b'den sqrt(den);' b'' b'if (den b'' b't radius den;' b'p3.x t;' b'p3.y t;' b'p3.z t;' b'' b'}' b'' b'subdivide_tri(&p1,&p2,&p3,freq);' b'' b'}' b'' b'}' b'' b'/* now the body b'' b'for (theta=0.0; theta<360.0; theta b'' b'rtheta theta*pi/180.0;' b'rtheta2 (theta+60.0)*pi/180.0;' b'ntheta (theta+36.0)*pi/180.0;' b'ntheta2 (theta+96.0)*pi/180.0;' b'p1.x radius*cos(rtheta);' b'p1.y northy;' b'p1.z radius*sin(rtheta);' b'p2.x radius*cos(rtheta2);' b'p2.y northy;' b'p2.z radius*sin(rtheta2);' b'p3.x radius*cos(ntheta);' b'p3.y southy;' b'p3.z radius*sin(ntheta);' b'p4.x radius*cos(ntheta2);' b'p4.y southy;' b'p4.z radius*sin(ntheta2);' b'' b'den (p1.x*p1.x)+(p1.y*p1.y)+(p1.z*p1.z);' b'den sqrt(den);' b'' b'if (den b'' b't radius den;' b'p1.x t;' b'p1.y t;' b'p1.z t;' b'' b'}' b'' b'den (p2.x*p2.x)+(p2.y*p2.y)+(p2.z*p2.z);' b'den sqrt(den);' b'' b'if (den b'' b't radius den;' b'p2.x t;' b'p2.y t;' b'p2.z t;' b'' b'}' b'den (p3.x*p3.x)+(p3.y*p3.y)+(p3.z*p3.z);' b'den sqrt(den);' b'if (den b'' b't radius den;' b'p3.x t;' b'p3.y t;' b'p3.z t;' b'' b'}' b'den (p4.x*p4.x)+(p4.y*p4.y)+(p4.z*p4.z);' b'den sqrt(den);' b'if (den b'' b't radius den;' b'p4.x t;' b'p4.y t;' b'p4.z t;' b'' b'}' b'' b'subdivide_tri(&p1,&p2,&p3,freq);' b'subdivide_tri(&p3,&p2,&p4,freq);' b'' b'}' b'' b'return;' b'' b'}' b'' b'#define norm_pt(v) register double r sqrt( v )-x v )-x b'( v )-y v )-y b'( v )-z v )-z b'( v )-x r; b'( v )-y r; b'( v )-z r; b'}' b'' b'subdivide_tri(p1,p2,p3,a)' b'' b'struct point_struct *p1, *p2, *p3;' b'int a;' b'' b'{' b'' b'struct point_struct n1, n2, n3;' b'struct point_struct p12, p13, p23;' b'double den, t;' b'' b'if (a0) b'' b'p12.x (p1-x+p2-x)/2.0;' b'p12.y (p1-y+p2-y)/2.0;' b'p12.z (p1-z+p2-z)/2.0;' b'den (p12.x*p12.x)+(p12.y*p12.y)+(p12.z*p12.z);' b'den sqrt(den);' b'if (den b'' b't radius den;' b'p12.x t;' b'p12.y t;' b'p12.z t;' b'' b'}' b'p13.x (p1-x+p3-x)/2.0;' b'p13.y (p1-y+p3-y)/2.0;' b'p13.z (p1-z+p3-z)/2.0;' b'den (p13.x*p13.x)+(p13.y*p13.y)+(p13.z*p13.z);' b'den sqrt(den);' b'if (den b'' b't radius den;' b'p13.x t;' b'p13.y t;' b'p13.z t;' b'' b'}' b'p23.x (p2-x+p3-x)/2.0;' b'p23.y (p2-y+p3-y)/2.0;' b'p23.z (p2-z+p3-z)/2.0;' b'den (p23.x*p23.x)+(p23.y*p23.y)+(p23.z*p23.z);' b'den sqrt(den);' b'if (den b'' b't radius den;' b'p23.x t;' b'p23.y t;' b'p23.z t;' b'' b'}' b'subdivide_tri(p1, &p12,&p13,a-1);' b'subdivide_tri(&p12, p2, &p23,a-1);' b'subdivide_tri(&p13,&p23, p3, a-1);' b'subdivide_tri(&p12,&p23,&p13,a-1);' b'' b'} else b'' b'n1.x p1-x;' b'n1.y p1-y;' b'n1.z p1-z;' b'norm_pt(&n1);' b'n2.x p2-x;' b'n2.y p2-y;' b'n2.z p2-z;' b'norm_pt(&n2);' b'n3.x p3-x;' b'n3.y p3-y;' b'n3.z p3-z;' b'norm_pt(&n3);' b'' b'/* nothing special about this poly b'' b'printf( "%f %f %f %f %f %f\\n", p1-x xorg,' b'p1-y yorg,' b'p1-z zorg,' b'n1.x, n1.y, n1.z b'printf( "%f %f %f %f %f %f\\n", p2-x xorg,' b'p2-y yorg,' b'p2-z zorg,' b'n2.x, n2.y, n2.z b'printf( "%f %f %f %f %f %f\\n", p3-x xorg,' b'p3-y yorg,' b'p3-z zorg,' b'n3.x, n3.y, n3.z b'' b'}' b'' b'return;' b'' b'}' b'--' b'san diego microscopy and imaging resource/uc san diego/la jolla, ca b'"my other car is a car, too."' b'- bumper strip seen on i-805' 