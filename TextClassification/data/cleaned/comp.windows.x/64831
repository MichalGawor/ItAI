b'' b'enclosed are the rules, guidelines and related information for the 10th' b'international obfuscated c code contest. (this is part of a part' b'shar file).' b'' b'enjoy!' b'' b'chongo <landon curt noll /\\oo/\\' b'larry bassel' b'' b'=-=' b'' b'#!/bin/sh' b'# this is part of a multipart archive' b'# mkentry.c b'echo "x extracting mkentry.c (text)"' b"sed 's/^x//' 'shar_eof' mkentry.c b'x/*' b'x copyright (c) landon curt noll larry bassel, b'x all rights reserved. permission for personal, education or non-profit use' b'x is granted provided this this copyright and notice are included in its' b'x entirety and remains unaltered. all other uses must receive prior' b'x permission in writing from both landon curt noll and larry bassel.' b'x b'x/*' b'x mkentry make an international obfuscated c code contest entry' b'x b'x usage:' b'x *\tmkentry -r remarks -b build -p prog.c -o ioccc.entry' b'x b'x *\t-r remarks\t\tfile with remarks about the entry' b'x *\t-b build\t\tfile containing how prog.c should be built' b'x *\t-p prog.c\t\tthe obfuscated program source file' b'x *\t-o ioccc.entry\t\tioccc entry output file' b'x b'x compile by:' b'x *\tcc mkentry.c -o mkentry' b'x b'x/*' b'x placed in the public domain by landon curt noll, b'x b"x this software is provided ``as is'' and without any express or implied" b'x warranties, including, without limitation, the implied warranties of' b'x merchantability and fitness for a particular purpose.' b'x b'x/*' b'x warning:' b'x b'x this program attempts to implement the ioccc rules. every attempt' b'x has been made to make sure that this program produces an entry that' b'x conforms to the contest rules. in all cases, where this program' b'x differs from the contest rules, the contest rules will be used. be' b'x sure to check with the contest rules before submitting an entry.' b'x b'x send questions or comments (but not entries) about the contest, to:' b'x b'x *\t...!{sun,pacbell,uunet,pyramid}!hoptoad!judges' b'x the rules and the guidelines may (and often do) change from year to' b'x year. you should be sure you have the current rules and guidelines' b'x prior to submitting entries. to obtain all of them, send email' b"x to the address above and use the subject 'send rules'." b'x b'x because contest rules change from year to year, one should only use this' b'x program for the year that it was intended. be sure that the rule_year' b'x define below matches this current year.' b'x b'x' b'x#include <stdio.h' b'x#include <ctype.h' b'x#include <time.h' b'x#include <sys/types.h' b'x#include <sys/stat.h' b'x' b'x/* logic b'x#ifndef true' b'x# define true b'x#endif true b'x#ifndef false' b'x# define false b'x#endif false b'x#define eof_ok true' b'x#define eof_not_ok false' b'x' b'x/* global limits b'x#define rule_year 1993\t\t/* note: should match the current year b'x#define start_date "1mar92 utc"\t/* first confirmation received b'x#define max_col 79\t\t/* max column a line should hit b'x#define max_build_size 256\t/* max how to build size b'x#define max_program_size 3217\t/* max program source size b'x#define max_program_size2 1536\t/* max program source size not counting' b'x\t\t\t\t whitespace and not followed by' b'x\t\t\t\t whitespace or eof b'x#define max_title_len 12\t/* max chars in the title b'x#define max_entry_len 1\t\t/* max length in the entry input line b'x#define max_entry 8\t\t/* max number of entries per person per year b'x#define max_file_len 1024\t/* max filename length for a info file b'x' b'x/* where to send entries b'x#define entry_addr1 "...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate"' b'x' b'x/* uuencode process assumes ascii b'x#define uuencode(c) (encode_str[(int)(c)&0xff])' b'x#define uuencode_len 45\t\t/* max uuencode chunk size b"x#define uuinfo_mode 0444\t/* mode of an info file's uuencode file b"x#define uubuild_mode 0444\t/* mode of the build file's uuencode file b'x#define uubuild_name "build"\t/* name for the build file\'s uuencode file b"x#define uuprog_mode 0444\t/* mode of the program's uuencode file b'x#define uuprog_name "prog.c"\t/* name for the program\'s uuencode file b'x' b'x/* encode_str[(char)val] is the uuencoded character of val b'x' b'x/* global declarations b'xchar *program;\t\t\t/* our name b'xlong start_time;\t\t/* the startup time b'x' b'x/* forward declarations b'xvoid parse_args();' b'xvoid usage();' b'xfile *open_remark();' b'xfile *open_build();' b'xfile *open_program();' b'xfile *open_output();' b'xvoid output_entry();' b'xvoid output_remark();' b'xvoid output_author();' b'xvoid output_info();' b'xvoid output_build();' b'xvoid output_program();' b'xvoid output_end();' b'xint get_line();' b'xvoid output_till_dot();' b'xint col_len();' b'xvoid check_io();' b'xvoid uuencode();' b'x' b'xmain(argc, argv)' b'x int argc;\t\t/* arg count b'x char **argv;\t/* the args b'x{' b'x file *remark=null;\t/* open remarks stream b'x file *build=null;\t/* open build file stream b'x file *prog=null;\t/* open program stream b'x file *output=null;\t/* open output stream b'x char *rname=null;\t/* file with remarks about the entry b'x char *bname=null;\t/* file containing how prog.c should be built b'x char *pname=null;\t/* the obfuscated program source file b'x char *oname=null;\t/* ioccc entry output file b'x struct tm *tm;\t/* startup time structure b'x' b'x b'x check on the year' b'x b'x start_time time((long b'x tm gmtime(&start_time);' b'x if (tm-tm_year rule_year-1900) b'x\tfprintf(stderr,' b'x\t"%s: warning: this program applies to %d, which may differ from %d\\n\\n",' b'x\t argv[0], rule_year, 1900+tm-tm_year);' b'x b'x' b'x b'x parse the command line args' b'x b'x parse_args(argc, argv, &rname, &bname, &pname, &oname);' b'x' b'x b'x open/check the input and output files' b'x b'x we open and truncate the output file first, in case it is the same' b'x as one of the input files.' b'x b'x output open_output(oname);' b'x remark open_remark(rname);' b'x build open_build(bname);' b'x prog open_program(pname);' b'x if (output==null remark==null build==null prog==null) b'x\texit(1);' b'x b'x' b'x b'x output each section' b'x b'x output_entry(output, oname);' b'x output_remark(output, oname, remark, rname);' b'x output_author(output, oname);' b'x output_info(output, oname);' b'x output_build(output, oname, build, bname);' b'x output_program(output, oname, prog, pname);' b'x output_end(output, oname);' b'x' b'x b'x flush the output' b'x b'x if (fflush(output) eof) b'x\tfprintf(stderr, "%s: flush error in %s: program, oname);' b'x\tperror("");' b'x\texit(2);' b'x b'x' b'x b'x final words' b'x b'x printf("\\nyour entry can be found in %s. you should check this file\\n",' b'x\toname);' b'x printf("correct any problems and verify that the uudecode utility will\\n");' b'x printf("correctly decode your build file and program.\\n\\n");' b'x printf("this program has been provided as a guide for submitters. in\\n");' b'x printf("cases where it conflicts with the rules, the rules shall apply.\\n");' b'x printf("it is your responsibility to ensure that your entry conforms to\\n");' b'x printf("the current rules.\\n\\n");' b'x printf("email your entries to:\\n");' b'x printf("\\t%s\\n", entry_addr1);' b'x printf("\\t%s\\n\\n", entry_addr2);' b'x printf("please use the following subject when you email your entry:\\n");' b'x printf("\\tioccc entry\\n\\n");' b'x all done b'x exit(0);' b'x}' b'x' b'x/*' b'x parse_args parse the command line args' b'x b'x given the command line args, this function parses them and sets the' b'x required name flags. this function will return only if the command' b'x line syntax is correct.' b'x b'xvoid' b'xparse_args(argc, argv, rname, bname, pname, oname)' b'x int argc;\t\t/* arg count b'x char **argv;\t/* the args b'x char **rname;\t/* file with remarks about the entry b'x char **bname;\t/* file containing how prog.c should be built b'x char **pname;\t/* the obfuscated program source file b'x char **oname;\t/* ioccc entry output file b'x{' b'x char *optarg;\t/* -flag option operand b'x int flagname;\t/* the name of the -flag b'x int i;' b'x' b'x b'x not everyone has getopt, so we must parse args by hand.' b'x b'x program argv[0];' b'x for (i=1; i argc; ++i) b'x' b'x\t/* determine the flagname b"x\tif (argv[i][0] b'x\t usage(1);' b'x\t /*notreached*/' b'x\t}' b'x\tflagname (int)argv[i][1];' b'x' b"x\t/* determine the flag's operand b"x\tif (flagname argv[i][2] b'x\t optarg &argv[i][2];' b'x\t} else b'x\t if (i+1 argc) b'x\t\tusage(2);' b'x\t\t/*notreached*/' b'x\t else b'x\t\toptarg argv[++i];' b'x\t b'x\t}' b'x' b"x\t/* save the flag's operand in the correct global variable b'x\tswitch (flagname) b"x\tcase 'r':" b'x\t *rname optarg;' b'x\t break;' b"x\tcase 'b':" b'x\t *bname optarg;' b'x\t break;' b"x\tcase 'p':" b'x\t *pname optarg;' b'x\t break;' b"x\tcase 'o':" b'x\t *oname optarg;' b'x\t break;' b'x\tdefault:' b'x\t usage(3);' b'x\t /*notreached*/' b'x\t}' b'x b'x' b'x b'x verify that we have all of the required flags' b'x b'x if (*rname null *bname null *pname null *oname null) b'x\tusage(4);' b'x\t/*notreached*/' b'x b'x return;' b'x}' b'x' b'x/*' b'x usage print a usage message and exit' b'x b'x this function does not return.' b'x b'xvoid' b'xusage(exitval)' b'x int exitval;\t\t/* exit with this value b'x{' b'x fprintf(stderr,' b'x\t"usage: %s -r remarks -b build -p prog.c -o ioccc.entry\\n\\n", program);' b'x fprintf(stderr, "\\t-r remarks\\tfile with remarks about the entry\\n");' b'x fprintf(stderr, "\\t-b build\\tfile containing how prog.c should be built\\n");' b'x fprintf(stderr, "\\t-p prog.c\\tthe obfuscated program source file\\n");' b'x fprintf(stderr, "\\t-o ioccc.entry\\tioccc entry output file\\n");' b'x exit(exitval);' b'x}' b'x' b'x/*' b'x open_remark open/check the remark file' b'x b'x the remark file should be indented by spaces, and should not extend' b'x beyond column max_col. these are not requirements, so we only warn.' b'x b'x this function returns null on i/o or format error.' b'x b'xfile b'xopen_remark(filename)' b'x char *filename;' b'x{' b'x file *stream;\t\t/* the opened file stream b'x char buf[bufsiz+1];\t\t/* input buffer b'x int toolong=0;\t\t/* number of lines that are too long b'x int non_indent=0;\t\t/* number of lines not indented by spaces b'x' b'x b'x open the remark input file' b'x b'x stream fopen(filename, "r");' b'x if (stream null) b'x\tfprintf(stderr, "%s: cannot open remark file: %s: b'x\t program, filename);' b'x\tperror("");' b'x\treturn(null);' b'x b'x' b'x b'x look at each line' b'x b'x while (fgets(buf, bufsiz, stream) null) b'x' b'x\t/* count lines that do not start with spaces b'x\tif (buf[0] \'\\n\' strncmp(buf, b'x\t ++non_indent;' b'x\t}' b'x' b'x\t/* count long lines b'x\tif (col_len(buf) max_col) b'x\t found a line that is too long b'x\t ++toolong;' b'x\t}' b'x b'x' b'x watch for i/o errors b'x check_io(stream, filename, eof_ok);' b'x' b'x note long lines if needed b'x if (toolong b'x\tfprintf(stderr,' b'x\t "%s: warning: %d line(s) from %s extend beyond the 80th column\\n",' b'x\t program, toolong, filename);' b'x\tfprintf(stderr,' b'x\t "%s: this is ok, but it would be nice to avoid\\n\\n",' b'x\t program);' b'x b'x' b'x note non-indented lines, if needed b'x if (non_indent b'x\tfprintf(stderr,' b'x\t "%s: warning: %d line(s) from %s are not indented by spaces\\n",' b'x\t program, non_indent, filename);' b'x\tfprintf(stderr,' b'x\t "%s: this is ok, but it would be nice to avoid\\n\\n",' b'x\t program);' b'x b'x' b'x return the open file b'x rewind(stream);' b'x return(stream);' b'x}' b'x' b'x/*' b'x open_build open/check the build file' b'x b'x the how to build file must not be longer than max_build_size bytes.' b'x b'x this function returns null on i/o or size error.' b'x b'xfile b'xopen_build(filename)' b'x char *filename;' b'x{' b'x file *stream;\t\t/* the opened file stream b'x struct stat statbuf;\t/* the status of the open file b'x' b'x b'x open the how to build input file' b'x b'x stream fopen(filename, "r");' b'x if (stream null) b'x\tfprintf(stderr, "%s: cannot open how to build file: %s: b'x\t program, filename);' b'x\tperror("");' b'x\treturn(null);' b'x b'x' b'x b'x determine the size of the file' b'x b'x if (fstat(fileno(stream), &statbuf) b'x\tfprintf(stderr, "%s: cannot stat how to build file: %s: b'x\t program, filename);' b'x\tperror("");' b'x\treturn(null);' b'x b'x if (statbuf.st_size max_build_size) b'x\tfprintf(stderr,' b'x\t "%s: fatal: the how to build file: %s, is %d bytes long\\n",' b'x\t program, filename, statbuf.st_size);' b'x\tfprintf(stderr,' b'x\t "%s: it may not be longer than %d bytes\\n",' b'x\t program, max_build_size);' b'x\treturn(null);' b'x b'x' b'x return the open file b'x return(stream);' b'x}' b'x' b'x/*' b'x open_program open/check the program source file' b'x b'x the program source file must be bytes. the number of' b'x non-whitespace and chars not followed by whitespace must' b'x be bytes.' b'x b'x this function returns null on i/o or size error.' b'x b'xfile b'xopen_program(filename)' b'x char *filename;' b'x{' b'x file *stream;\t\t/* the opened file stream b'x struct stat statbuf;\t/* the status of the open file b'x int count;\t\t\t/* special count size b'x int c;\t\t\t/* the character read b'x' b'x b'x open the program source input file' b'x b'x stream fopen(filename, "r");' b'x if (stream null) b'x\tfprintf(stderr, "%s: cannot open program source file: %s: b'x\t program, filename);' b'x\tperror("");' b'x\texit(7);' b'x b'x' b'x b'x determine the size of the file' b'x b'x if (fstat(fileno(stream), &statbuf) b'x\tfprintf(stderr, "%s: cannot stat program source file: %s: b'x\t program, filename);' b'x\tperror("");' b'x\treturn(null);' b'x b'x if (statbuf.st_size max_program_size) b'x\tfprintf(stderr,' b'x\t "%s: fatal: the program source file: %s, is %d bytes long\\n",' b'x\t program, filename, statbuf.st_size);' b'x\tfprintf(stderr,' b'x\t "%s: it may not be longer than %d bytes\\n",' b'x\t program, max_program_size);' b'x\treturn(null);' b'x b'x' b'x b'x count the non-whitespace, non followed by whitespace chars' b'x b'x count b'x c b'x while ((c=fgetc(stream)) eof) b'x\t/* look at non-whitespace b'x\tif (!isascii(c) !isspace(c)) b'x\t switch (c) b"x\t case '{':\t\t/* count if not followed by eof or whitespace b"x\t case b"x\t case b'x\t\t/* peek at next char b'x\t\tc fgetc(stream);' b'x\t\tif (c eof isascii(c) !isspace(c)) b'x\t\t not followed by whitespace or eof, count it b'x\t\t ungetc(c, stream);' b'x\t\t ++count;' b'x\t\t}' b'x\t\tbreak;' b'x\t default:' b'x\t\t++count;' b'x\t\tbreak;' b'x\t b'x\t}' b'x b'x' b'x watch for i/o errors b'x check_io(stream, filename, eof_ok);' b'x' b'x look at the special size b'x if (count max_program_size2) b'x\tfprintf(stderr,' b'x\t "%s: fatal: the number of bytes that are non-whitespace, and\\n",' b'x\t program);' b'x\tfprintf(stderr,' b'x\t "%s: that are not followed by whitespace\\n",' b'x\t program);' b'x\tfprintf(stderr,' b'x\t "%s: or eof must be %d bytes\\n",' b'x\t program, max_program_size2);' b'x\tfprintf(stderr,' b'x\t "%s: in %s, %d bytes were found\\n",' b'x\t program, filename, count);' b'x\treturn(null);' b'x b'x' b'x return the open file b'x rewind(stream);' b'x return(stream);' b'x}' b'x' b'x/*' b'x open_output open/check the entry output file' b'x b'x this function returns null on open error.' b'x b'xfile b'xopen_output(filename)' b'x char *filename;' b'x{' b'x file *stream;\t\t/* the opened file stream b'x' b'x b'x open the ioccc entry output file' b'x b'x stream fopen(filename, "w");' b'x if (stream null) b'x\tfprintf(stderr, "%s: cannot open ioccc entry file for output: %s: b'x\t program, filename);' b'x\tperror("");' b'x\texit(8);' b'x b'x' b'x return the open file b'x return(stream);' b'x}' b'x' b'x/*' b'x output_entry output the ---entry--- section' b'x b'x read the needed information form stdin, and write the entry section.' b'x b'xvoid' b'xoutput_entry(output, oname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x{' b"x char title[max_title_len+1+1];\t/* the entry's title b'x char buf[max_col+1+1];\t\t/* i/o buffer b'x int entry=0;\t\t\t/* entry number b'x int ret;\t\t\t\t/* fields processed by fscanf b'x int ok_line=0;\t\t\t/* the line is not ok b'x char skip;\t\t\t\t/* input to skip b'x file *date_pipe;\t\t\t/* pipe to a date command b'x time_t epoch_sec;\t\t\t/* seconds since the epoch b'x char *p;' b'x' b'x b'x write the start of the section' b'x b'x fprintf(output, "---entry---\\n");' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x write the rule year' b'x b'x fprintf(output, "rule:\\t%d\\n", rule_year);' b'x check_io(output, oname, eof_not_ok);' b'x' b'x determine if this is a fix b'x printf("is this a fix, update or resubmittion to a b'x printf("previous entry (enter y or n)? b"x while (get_line(buf, !(buf[0]=='y' buf[0]=='n')) b'x\tprintf("\\nplease answer y or n: b'x b"x if (buf[0] 'y') b'x\tfprintf(output, "fix:\\ty\\n");' b'x\tcheck_io(output, oname, eof_not_ok);' b'x\tprintf("\\nbe sure that the title and entry number that you give\\n");' b'x\tprintf("are the same of as the entry you are replacing\\n");' b'x else b'x\tfprintf(output, "fix:\\tn\\n");' b'x\tcheck_io(output, oname, eof_not_ok);' b'x b'x' b'x b'x write the title' b'x b'x printf("\\nyour title must match expression be a [a-za-z0-9_=] character\\n");' b'x printf("followed by to %d more [a-za-z0-9_=+-] characters.\\n\\n",' b'x\tmax_title_len-1);' b'x printf("it is suggested, but not required, that the title should\\n");' b'x printf("incorporate your username; in the\\n");' b'x printf("case of multiple authors, consider using parts of the usernames\\n");' b'x printf("of the authors.\\n\\n");' b'x printf("enter your title: b'x do b'x\t/* prompt and read a line b'x\tif ((ok_line get_line(title, max_title_len+1, max_col-9)) b'x\t printf("\\ntitle is too long, please re-enter: b'x\t continue;' b'x\t}' b'x' b'x\t/* verify the pattern, not everyone has regexp, so do it by hand b'x\tif (!isascii((int)title[0]) b"x\t !(isalnum((int)title[0]) title[0] title[0] b'x\t printf("\\ninvalid first character in the title\\n\\n");' b'x\t printf("enter your title: b'x\t ok_line b'x\t} else b"x\t for (p=(&title[1]); *p *p '\\n'; ++p) b'x\t\tif (!isascii((int)*p) b'x\t\t !(isalnum((int)*p) b"x\t\t *p *p *p *p b'x\t\t printf("\\ninvalid character in the title\\n\\n");' b'x\t\t printf("enter your title: b'x\t\t ok_line b'x\t\t}' b'x\t b'x\t}' b'x while (ok_line b'x fprintf(output, "title:\\t%s", title);' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x write the entry number' b'x b'x printf("\\neach person may submit up to %d entries per year.\\n\\n",' b'x\tmax_entry);' b'x printf("enter an entry number from to %d inclusive: max_entry-1);' b'x do b'x\t/* get a valid input line b'x\tfflush(stdout);' b'x\tret fscanf(stdin, "%d[\\n]", &entry);' b'x\tcheck_io(stdin, "stdin", eof_not_ok);' b'x\t/* skip over input until newline is found b'x\tdo b'x\t skip fgetc(stdin);' b'x\t check_io(stdin, "stdin", eof_not_ok);' b"x\t if (skip '\\n') b'x\t\t/* bad text in input, invalidate entry number b'x\t\tentry b'x\t b"x\t} while (skip '\\n');" b'x' b'x\t/* check if we have a number, and if it is in range b'x\tif (ret entry entry max_entry-1) b'x\t printf(' b'x\t "\\nthe entry number must be between and %d inclusive\\n\\n",' b'x\t\tmax_entry-1);' b'x\t printf("enter the entry number: b'x\t}' b'x while (ret entry entry max_entry-1);' b'x fprintf(output, "entry:\\t%d\\n", entry);' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x write the submission date' b'x b'x returns a newline b'x epoch_sec time(null);' b'x fprintf(output, "date:\\t%s", asctime(gmtime(&epoch_sec)));' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x write the os/machine host information' b'x b'x printf(' b'x "\\nenter the machine(s) and os(s) under which your entry was tested.\\n");' b'x output_till_dot(output, oname, "host:");' b'x}' b'x' b'x/*' b'x output_remark output the ---remark--- section' b'x b'x read the needed information form stdin, and write the entry section.' b'x b'xvoid' b'xoutput_remark(output, oname, remark, rname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x file *remark;\t\t/* stream to the file containing remark text b'x char *rname;\t\t/* name of the remark file b'x{' b'x char buf[bufsiz+1];\t\t/* input/output buffer b'x' b'x b'x write the start of the section' b'x b'x fprintf(output, "---remark---\\n");' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x copy the remark file to the section' b'x b'x while (fgets(buf, bufsiz, remark) null) b'x\tfputs(buf, output);' b'x\tcheck_io(output, oname, eof_not_ok);' b'x b'x check_io(remark, rname, eof_ok);' b'x' b'x be sure that the remark section ends with a newline b"x if (buf[strlen(buf)-1] '\\n') b"x\tfputc('\\n', output);" b'x\tcheck_io(output, oname, eof_not_ok);' b'x b'x}' b'x' b'x/*' b'x output_author output the ---author--- section' b'x b'x read the needed information from stdin, and write the author section.' b'x if multiple authors exist, multiple author sections will be written.' b'x b'xvoid' b'xoutput_author(output, oname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x{' b'x char buf[max_col+1+1];\t/* i/o buffer b'x int more_auths;\t\t/* true more authors to note b'x int auth_cnt=0;\t\t/* number of authors processed b'x' b'x b'x prompt the user for the author section' b'x b'x printf("\\nenter information about each author. if your entry is after\\n");' b'x printf("%s and before the contest deadline, the judges\\n", start_date);' b'x printf("will attempt to email back a confirmation to the first author\\n");' b'x' b'x b'x place author information for each author in an individual section' b'x b'x do b'x' b'x\t/* write the start of the section b'x\tfprintf(output, "---author---\\n");' b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/* write the author b'x\tprintf("\\nauthor #%d name: ++auth_cnt);' b'x\twhile (get_line(buf, max_col+1, max_col-9) b'x\t printf("\\nname too long, please re-enter: b'x\t}' b'x\tfprintf(output, "name:\\t%s", buf);' b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/* write the organization b'x\tprintf("\\nenter the school/company/organization of author #%d\\n",' b'x\t auth_cnt);' b'x\tprintf("\\nauthor #%d org: auth_cnt);' b'x\twhile (get_line(buf, max_col+1, max_col-9) b'x\t printf("\\nline too long, please re-enter: b'x\t}' b'x\tfprintf(output, "org:\\t%s", buf);' b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/* write the address b'x\tprintf(' b'x\t "\\nenter the postal address for author #%d. be sure to include\\n",' b'x\t auth_cnt);' b'x\tprintf("your country and do not include your name.\\n");' b'x\toutput_till_dot(output, oname, "addr:");' b'x' b'x\t/* write the email address b'x\tprintf(' b'x\t "\\nenter the email address for author #%d. use an address from\\n",' b'x\t auth_cnt);' b'x\tprintf(' b'x\t "a registered domain or well known site. if you give several\\n");' b'x\tprintf("forms, list them one per line.\\n");' b'x\toutput_till_dot(output, oname, "email:");' b'x' b'x\t/* write the anonymous status b'x\tprintf("\\nshould author #%d remain anonymous (enter y or n)? b'x\t auth_cnt);' b"x\twhile (get_line(buf, !(buf[0]=='y' buf[0]=='n')) b'x\t printf("\\nplease answer y or n: b'x\t}' b'x\tfprintf(output, "anon:\\t%s", buf);' b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/* determine if there is another author b'x\tprintf("\\nis there another author (enter y or n)? b"x\twhile (get_line(buf, !(buf[0]=='y' buf[0]=='n')) b'x\t printf("\\nplease answer y or n: b'x\t}' b"x\tif (buf[0] 'y') b'x\t more_auths true;' b'x\t} else b'x\t more_auths false;' b'x\t}' b'x while (more_auths true);' b'x return;' b'x}' b'x' b'x/*' b'x output_info output the ---info--- section(s)' b'x b'x read the needed information from stdin, and write the info section.' b'x if multiple info files exist, multiple info sections will be written.' b'x b'xvoid' b'xoutput_info(output, oname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x{' b'x char infoname[max_file_len+1];\t/* filename buffer b'x char yorn[1+1];\t\t/* y or n answer b'x char *uuname;\t\t/* name to uuencode as b'x file *infile;\t\t/* info file stream b'x' b'x b'x prompt the user for info information' b'x b'x printf("\\ninfo files should be used only to supplement your entry.\\n");' b'x printf("for example, info files may provide sample input or detailed\\n");' b'x printf("information about your entry. because they are supplemental,\\n");' b'x printf("the entry should not require them to exist.\\n\\n");' b'x' b'x b'x while there is another info file to save, uuencode it' b'x b'x printf("do you have a info file to include (enter y or n)? b"x while (get_line(yorn, !(yorn[0]=='y' yorn[0]=='n')) b'x\tprintf("\\nplease answer y or n: b'x b"x while (yorn[0] 'y') b'x' b'x\t/* read the filename b'x\tprintf("\\nenter the info filename: b'x\twhile (get_line(infoname, max_file_len+1, b'x\t printf("\\ninfo filename too long, please re-enter: b'x\t}' b'x' b'x\t/* compute the basename of the info filename b'x\t/* remove the trailing newline b'x\tuuname &infoname[strlen(infoname)-1];' b"x\t*uuname b'x\t/* avoid rindex/shrrchr compat issues, do it by hand b'x\tfor (--uuname; uuname infoname; --uuname) b"x\t if (*uuname b'x\t\t++uuname;' b'x\t\tbreak;' b'x\t b'x\t}' b'x' b'x\t/* attempt to open the info file b'x\tinfile fopen(infoname, "r");' b'x\tif (infile null) b'x\t fprintf(stderr, "\\n%s: cannot open info file: %s: b'x\t\tprogram, infoname);' b'x\t perror("");' b'x\t continue;' b'x\t}' b'x' b'x\t/*' b'x\t write the start of the section' b'x\t b'x\tfprintf(output, "---info---\\n");' b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/* uuencode the info file b'x\tuuencode(output, oname, infile, infoname, uuinfo_mode, uuname);' b'x' b'x\tprintf("\\ndo you have another info file to include (enter y or n)? b"x\twhile (get_line(yorn, !(yorn[0]=='y' yorn[0]=='n')) b'x\t printf("\\nplease answer y or n: b'x\t}' b'x b'x return;' b'x}' b'x' b'x/*' b'x output_build output the ---build--- section' b'x b'x read the needed information from stdin, and write the build section.' b'x b'xvoid' b'xoutput_build(output, oname, build, bname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x file *build;\t\t/* open build file stream b'x char *bname;\t\t/* name of the build file b'x{' b'x b'x write the start of the section' b'x b'x fprintf(output, "---build---\\n");' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x uuencode the program file' b'x b'x uuencode(output, oname, build, bname, uubuild_mode, uubuild_name);' b'x return;' b'x}' b'x' b'x/*' b'x output_program output the ---program--- section' b'x b'x read the needed information form stdin, and write the program section.' b'x b'xvoid' b'xoutput_program(output, oname, prog, pname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x file *prog;\t\t\t/* open program stream b'x char *pname;\t\t/* name of program file b'x{' b'x b'x write the start of the section' b'x b'x fprintf(output, "---program---\\n");' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x uuencode the program file' b'x b'x uuencode(output, oname, prog, pname, uuprog_mode, uuprog_name);' b'x return;' b'x}' b'x' b'x/*' b'x output_end output the ---end--- section' b'x b"x read the needed information form stdin, and write the 'end section'." b'x b'xvoid' b'xoutput_end(output, oname)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x{' b'x b'x write the final section terminator' b'x b'x fprintf(output, "---end---\\n");' b'x check_io(output, oname, eof_not_ok);' b'x return;' b'x}' b'x' b'x/*' b'x get_line get an answer from stdin' b'x b'x this function will flush stdout, in case a prompt is pending, and' b'x read in the answer.' b'x b'x this function returns if the line is too long, of the length of the' b'x line (including the newline) of the line was ok. this function does' b'x not return if error or eof.' b'x b'xint' b'xget_line(buf, siz, maxcol)' b'x char *buf;\t\t\t/* input buffer b'x int siz;\t\t\t/* length of input, including the newline b'x int maxcol;\t\t\t/* max col allowed, disable check b'x{' b'x int length;\t\t\t/* the length of the input line b'x' b'x flush terminal output b'x fflush(stdout);' b'x' b'x read the line b'x if (fgets(buf, siz+1, stdin) null) b'x\t/* report the problem b'x\tcheck_io(stdin, "stdin", eof_not_ok);' b'x b'x' b'x look for the newline b'x length strlen(buf);' b"x if (buf[length-1] '\\n') b'x\tint eatchar;\t\t/* the char being eaten b'x' b'x\t/* no newline found, line must be too long, eat the rest of the line b'x\tdo b'x\t eatchar fgetc(stdin);' b"x\t} while (eatchar eof eatchar '\\n');" b'x\tcheck_io(stdin, "stdin", eof_not_ok);' b'x' b'x\t/* report the situation b'x\treturn b'x b'x' b'x watch for long lines, if needed b'x if (maxcol (length maxcol col_len(buf) maxcol)) b'x\t/* report the situation b'x\treturn b'x b'x' b'x return length b'x return length;' b'x}' b'x' b'x/*' b"x output_till_dot output a set of lines until by itself is read" b'x b'x this routine will read a set of lines until (but not including)' b"x a single line with is read. the format of the output is:" b'x b'x *\tleader:\\tfirst line' b'x *\t\\tnext line' b'x *\t\\tnext line' b'x *\t b'x b'x this routine will not return if i/o error or eof.' b'x b'xvoid' b'xoutput_till_dot(output, oname, leader)' b"x file *output;\t\t/* entry's output file stream b'x char *oname;\t\t/* name of the output file b'x char *leader;\t\t/* the lead text for the first line b'x{' b'x char buf[bufsiz+1];\t\t/* input buffer b'x int count;\t\t\t/* lines read b'x int done=false;\t\t/* true finished reading input b'x' b'x instruct the user on how to input b'x printf("\\nto end input, enter a line with a single period.\\n");' b'x' b"x read lines until or eof b'x count b'x while (!done) b'x\t/* issue the prompt b'x\tprintf("%s\\t", (count0) leader);' b'x\tfflush(stdout);' b'x' b'x\t/* get the line b'x\tif (get_line(buf, bufsiz, max_col-9) b'x\t printf("\\nline too long, please re-enter:\\n\\t");' b'x\t continue;' b'x\t}' b'x' b"x\t/* note if was read b'x\tif (strcmp(buf, ".\\n") b'x\t done true;' b'x\t}' b'x' b'x\t/* write line if we read something b'x\tif (!done) b'x\t fprintf(output, "%s\\t%s", (count++0) leader, buf);' b'x\t check_io(output, oname, eof_not_ok);' b'x\t}' b'x b'x' b'x if no lines read, at least output something b'x if (count b'x\tfprintf(output, "%s\\t.\\n", leader);' b'x\tcheck_io(output, oname, eof_not_ok);' b'x b'x return;' b'x}' b'x' b'x/*' b'x col_len determine the highest that a string would reach' b'x b'x given a string, this routine returns that a string would reach' b'x if the string were printed at column tab stops are assumed' b'x to start at b'x b'xint' b'xcol_len(string)' b'x char *string;\t\t/* the string to examine b'x{' b'x int col;\t/* current column b'x char *p;\t/* current char b'x' b'x scan the string b"x for (col=0, p=string; *p *p '\\n'; ++p) b'x\t/* note the column shift b"x\tcol (*p=='\\t') 1+((col+8)/8*8) col+1;" b'x b"x if (*p '\\n') b'x\t--col;' b'x b'x' b'x return the highest column b'x return col;' b'x}' b'x' b'x/*' b'x check_io check for eof or i/o error on a stream' b'x b'x does not return if eof or i/o error.' b'x b'xvoid' b'xcheck_io(stream, name, eof_ok)' b'x file *stream;\t\t/* the stream to check b'x char *name;\t\t\t/* the name of this stream b'x int eof_ok;\t\t\t/* eof_ok or eof_not_ok b'x{' b'x test for i/o error b'x if (ferror(stream)) b'x\tfprintf(stderr, "%s: error on %s: program, name);' b'x\tperror("");' b'x\texit(1);' b'x' b'x test for eof b'x else if (eof_ok eof_not_ok feof(stream)) b'x\tfprintf(stderr, "%s: eof on %s\\n", program, name);' b'x\texit(1);' b'x b'x return;' b'x}' b'x' b'x/*' b'x uuencode uuencode a file' b'x b'x perform the uuencoding process identical to the process performed' b'x by the uuencode(1) utility.' b'x b'x this routine implements the algorithm described in the uuencode(5)' b'x 4.3bsd reno man page.' b'x b'xvoid' b'xuuencode(output, oname, infile, iname, umode, uname)' b'x file *output;\t\t/* output file stream b'x char *oname;\t\t/* output filename b'x file *infile;\t\t/* input file stream b'x char *iname;\t\t/* input filename b'x int umode;\t\t\t/* the mode to put on the uuencode file b'x char *uname;\t\t/* name to put on the uuencode file b'x{' b'x char buf[uuencode_len+1];\t/* the uuencode buffer b'x int read_len;\t\t/* actual number of chars read b'x int val;\t\t\t/* bit chunk from buf b"x char filler='\\0';\t\t/* filler uuencode pad text b'x char *p;' b'x' b'x b'x output the initial uuencode header' b'x b'x fprintf(output, "begin %o %s\\n", umode, uname);' b'x check_io(output, oname, eof_not_ok);' b'x' b'x b'x clear out the input buffer' b'x b'x for (p=buf; p &buf[sizeof(buf)/sizeof(buf[0])]; ++p) b"x\t*p b'x b'x' b'x b'x we will process uuencode_len chars at a time, forming' b'x a single output line each time.' b'x b'x while ((read_len=fread(buf,sizeof(buf[0]),uuencode_len,infile)) b'x' b'x\t/*' b'x\t the first character is the length character' b'x\t b'x\tfputc(uuencode(read_len), output);' b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/*' b'x\t we will convert bits at a time. thus we will convert' b'x\t sets of bits into sets of uuencoded bits.' b'x\t b'x\tfor (p=buf; read_len0; read_len-=3, p+=3) b'x' b'x\t bits to b'x\t val (p[0]2)&0x3f;' b'x\t fputc(uuencode(val), output);' b'x\t check_io(output, oname, eof_not_ok);' b'x' b'x\t bits to b'x\t val ((p[0]<<4)&0x30) ((p[1]4)&0x0f);' b'x\t fputc(uuencode(val), output);' b'x\t check_io(output, oname, eof_not_ok);' b'x' b'x\t bits to b'x\t val ((p[1]<<2)&0x3c) ((p[2]6)&0x03);' b'x\t fputc(uuencode(val), output);' b'x\t check_io(output, oname, eof_not_ok);' b'x' b'x\t bits to b'x\t val p[2]&0x3f;' b'x\t fputc(uuencode(val), output);' b'x\t check_io(output, oname, eof_not_ok);' b'x\t}' b'x' b'x\t/* end of uuencode_len line b"x\tfputc('\\n', output);" b'x\tcheck_io(output, oname, eof_not_ok);' b'x' b'x\t/*' b"x\t clear out the input buffer (don't depend on bzero() or memset())" b'x\t b'x\tfor (p=buf; p &buf[sizeof(buf)/sizeof(buf[0])]; ++p) b"x\t *p b'x\t}' b'x b'x' b'x check the last read on the input file b'x check_io(infile, iname, eof_ok);' b'x' b'x write end of uuencode file b'x fprintf(output, "%c\\nend\\n", uuencode(filler));' b'x check_io(output, oname, eof_not_ok);' b'x}' b'shar_eof' b'chmod mkentry.c b'echo "restore of mkentry.c failed"' b'set `wc -c mkentry.c`;wc_c=$1' b'if test "$wc_c" then' b'echo original size current size $wc_c' b'fi' b'# obfuscate.info b'echo "x extracting obfuscate.info (text)"' b"sed 's/^x//' 'shar_eof' obfuscate.info b'x1993 obfuscated contest information' b'x' b'xcopyright (c) landon curt noll larry bassel, b'xall rights reserved. permission for personal, education or non-profit use is' b'xgranted provided this this copyright and notice are included in its entirety' b'xand remains unaltered. all other uses must receive prior permission in writing' b'xfrom both landon curt noll and larry bassel.' b'x' b'xthe international obfuscated c code contest (ioccc), in the sprit of' b'xco-operation, is willing mention other programming contents, as space' b'xpermits.' b'x' b'xhow to have your contest included in this file:' b'x' b'x if you wish the ioccc judges to include your contest in this file,' b'x send a request to:' b'x' b'x' b'x we request that contest descriptions be limited to lines and to' b'x not exceed bytes. we typically request that your contest' b'x include a current description of the ioccc.' b'x' b'x in order to be included in this file for given year, we must' b'x receive a current description no earlier than jan utc and' b'x no later than feb utc. agreement to publish your' b'x contest must also be obtained prior to feb annual contests' b'x that fail to submit a new entry will be dropped from this file.' b'x' b'xofficial disclaimer: (pardon the officialese)' b'x' b'x the contents noted below, other than the ioccc, are not affiliated' b'x with the ioccc, nor are they endorsed by the ioccc. we reserve the' b'x right to refuse to print information about a given contest.' b'x' b'x the information below was provided by the particular contest' b'x organizer(s) and printed by permission. please contact the' b'x contest organizer(s) directly regarding their contents.' b'x' b'xwith that official notice given, we present for your enjoyment, the following' b'xinformation about contents:' b'x' b'x---------------------------------------------------------------------------' b'x' b'x 10th international obfuscated c contest' b'x' b'x\t"the original obfuscated contest"' b'x' b'x obfuscate: tr.v. -cated, -cating, -cates. a. to render obscure.' b'x b. to darken. to confuse: their emotions obfuscated' b'x\t\ttheir judgment. [llat. obfuscare, to darken ob(intensive) b'x lat. fuscare, to darken fuscus, dark.] -obfuscation n.' b'x obfuscatory adj.' b'x' b'x goals of the contest:' b'x' b'x to write the most obscure/obfuscated c program under the rules below.' b'x to show the importance of programming style, in an ironic way.' b'x to stress c compilers with unusual code.' b'x to illustrate some of the subtleties of the c language.' b'x to provide a safe forum for poor c code. b'x' b'x the ioccc is the grandfather of usenet programming contests. since' b'x this contest demonstrated that a program that mearly works' b'x correctly is not sufficient. the ioccc has also done much to add' b"x the arcane word 'obfuscated' back into the english language." b'x (see "the new hacker\'s dictionary" by eric raymond)' b'x' b'x you are strongly encouraged to read the new contest rules before' b'x sending any entries. the rules, and sometimes the contest email' b'x address itself, change over time. a valid entry one year may' b'x be rejected in a later year due to changes in the rules. the typical' b'x start date for contests is in early march. contest rules are normally not' b'x finalized and posted until the beginning of the contest. the typical' b'x closing date for contests are in early may.' b'x' b'x the contest rules are posted to comp.unix.wizards, comp.lang.c,' b'x misc.misc, alt.sources and comp.sources.d. if you do not have access' b'x to these groups, or if you missed the early march posting, you may' b'x request a copy from the judges, via email, at;' b'x' b'x' b'x previous contest winners are available via anonymous ftp from' b'x ftp.uu.net under the directory /pub/ioccc.' b'x' b'x---------------------------------------------------------------------------' b'x' b'x 0th international obfuscated perl contest' b'x\tby: landon noll larry wall' b'x' b'x this content is being planned. someday when landon larry are not too' b'x busy, they will actually get around to posting the first set of rules!' b'x' b'x landon says: "yes, i know that i said we would have a contest in b'x\t\t but other existing projects got in the way. hopefully' b'x\t\t something will be developed after nov b'x' b'x---------------------------------------------------------------------------' b'x' b'x 2nd international obfuscated postscript contest' b'x' b'x a contest of programming skills and knowledge, exclusively for the' b'x postscript programming language. its purpose:' b'x' b'x to spread knowledge of postscript and its details.' b'x to applaud those with the best tricks.' b'x to prove that humans can beat those damnable machine generators at' b'x their own game by writing the most obscure and mysterious postscript' b'x programs ever.' b'x' b'x winners will receive the fame and attention that goes with having their' b'x program entry posted as a winner to programmers world-wide.' b'x' b'x the contest rules and results are available by ftp as' b"x ``wilma.cs.brown.edu:pub/postscript/obfuscated*.shar'', or individually" b'x in the obfuscated directory. the judges will post the rules' b'x in november to comp.lang.postscript on usenet, and other places.' b'x' b'x categories include: best obfuscated postscript, best artwork,' b'x most compact, best interactive program, most useful, and' b'x anything so unusual and creative that it deserves an award.' b'x' b'x the judges will choose the winners of each category.' b'x' b'x alena lacova is a system administrator at nikhef (institute for high' b'x energy and nuclear physics) in the netherlands. she is the author of' b'x the postscript chaos programs, which draw julia sets, mandelbrot sets' b'x and other kinds of fractal functions.' b'x' b'x jonathan monsarrat is a graduate student from mit and brown university' b'x in the u.s.a. he is the faq maintainer for the usenet newsgroup' b'x comp.lang.postscript and the author of the postscript zone and lametex.' b'x b'x' b'shar_eof' b'chmod obfuscate.info b'echo "restore of obfuscate.info failed"' b'set `wc -c obfuscate.info`;wc_c=$1' b'if test "$wc_c" then' b'echo original size current size $wc_c' b'fi' b'exit b'--' b'sunnyvale residents: vote landon noll for sunnyvale city council seat 