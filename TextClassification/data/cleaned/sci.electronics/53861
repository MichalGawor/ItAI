b'' b'suppose we have a boolean function which is a minimal sum-of-products' b'(derived from a k-map or something), like this:' b'' b"f(a,b,c,d) bc'd' acd' abc' ab'c" b'' b'the books on logic design i have consulted all seem to imply that this' b'is where the analysis ends but by factoring out the' b"`a' term in the function, we can get fewer gates:" b'' b"f(a,b,c,d) bc'd' a(cd' bc' b'c)," b'' b'which yields gates.' b'' b'yes, but... the minimization of gates is important in part' b'because of timing considerations. a ttl gate has the basic structure' b'of and/or/invert, and an inversion of a sum of a product is just' b'exactly one gate delay. the reason to find a minimal sum of products' b'is that this matches a hardware optimization.' b'' b'a positive-or gate (such as the 9-gate solution uses) has' b"two gate delays (and there's another gate delay in the second term)" b'so that the second solution, while simpler in logic symbols, can' b'be expected to be something less than optimal in the real world.' b'ecl is similar to ttl, in that it can support an or/and' b'gate with the minimum delay (unlike ttl, you get both true and' b"inverse outputs for 'free' when using ecl)." b'' b'pals are basically large programmable and/or/invert' b'gates (with your choice of internal connections between the' b'various sections, and perhaps some latches), so a minimum sum' b'of products also is a way to shoehorn a logic design into' b"a few pals. it's not comparably easy to design with a minimization" b'of logic gates, but some software packages claim to allow you to' b'do so, and will take just about any mess of gates (as a nodelist' b'with 74xxx series logic ics) and produce a description of' b"a logic cell array to do the same job. xilinx's xact software" b'does this by treating each logic block as a macro, and expanding' b'it all out, then simplifying.' b'' b'john whitmore' 