b'' b'i can think of a couple of ways of guaranteeing authenticity in a one-time' b"pad encrytped scheme, though i'm not sure how to prove that what kind of" b'authenicity they provide.' b'' b'an obvious first-attempt might be to prepend a truly random (unpredictable' b'for eve) block to the message, and then calculate a crc which included the' b'random starting block and all of the message. this could be encrypted after' b"the message. the problem is, i'm not sure it's impossible to come up with" b'a message that will hash to the same crc regardless of the random starting' b"block. (it intuitively seems like it ought to be hard, but i'm not *that*" b'sure....) clearly, a crypto-strength hash like md5 or the sha would be' b"stronger, but again, i'm not sure i'm comfortable claiming that it's" b'unbreakable.' b'' b"a scheme to use up some of the pad bits to decide how many bits of 0's" b"to include in the plaintext stream before going on wouldn't be too bad," b'either. at the cost of increasing the speed with which you use up your' b'pad, this could be used to give you arbitrarily low probability that your' b'opponent could spoof a valid-looking message, since any deciphered plaintext' b"in a spot that should be carrying 0's will show that something funny's going" b'on.' b'' b'if, for each message bit m_i, we used up one random bit, r_i, to decide' b"whether to insert a into the plaintext stream, we'd get a total pad use" b"of times the message length. (we'd expand the message size by about" b"half.) each that should appear in the plaintext stream that doesn't is a" b"guess for our would-be spoofer. at each bit, she has to guess. i'm trying" b'to see how to quantify her chances of making it all the way through the' b'spoofed message, but it gets a little complicated, because she can get un-' b'synched, and still happen to have a in that place in the spoofed message.' b'' b"now, i can see a simple way of doing this that's got to be as secure" b'as a one-time pad, at a cost of using times the message length in pad bits.' b'' b'for each message bit, m_i, use one random bit, r_i, and xor them together' b'to get x_i. now, encrypt the three bits with the one-time pad. the enemy' b"has no way of guessing what r_i is, so he/she can't guess what x_i is, either." b'any change she makes in the ciphertext stream will have to involve a guess' b'of what r_i was. is there any way to do this without using so many pad bits?' b'' b'spoofing the message is equivalent to correctly guessing as many random' b'bits as there are bits in the message. clearly, this makes spoofing messages' b'just as hard if you know the whole message text as if you know none of it.' b'in fact, it looks to me like this makes it just as hard to generate a spoofed' b"message with the ciphertext as without it, but i'm not entirely sure about" b'that.' b'' b"is there an easier way of doing this that's provably as secure as the" b'one-time pad?' b'' b'--john kelsey' 