b'' b'hello. i hope somebody out here can help me. i am currently working' b'on a project where i am trying to communicate from an ibm with' b'phoenix bios, using c++, to a board that i made with an intel cpu' b'with uart chip. the board works fine with the transmit command and' b'terminal emulation mode of kermit, but there seems to be something wrong' b'with the initialization or protocol used when i try c++. i need to' b'access the unit i built using c, because i have a sizable chunk of c' b'code that i will be using to perform calculations and operations that' b'will be very difficult to code in assembly language for the b'' b'i have included the assembly code that i am running and the c++ code' b'that i am trying to use. if anyone can show me something that i' b'am doing blatantly incorrectly or that i am missing because of my lack' b'of knowledge about rs-232 serial communications, please e-mail me.' b'i wrote the assembly language to wait for a character to be received and' b'then to check it against the 0x20 character, if a 0x20 is received,' b'the leds will indicate this. two c++ programs that i have written do' b'nothing, but set up com port and send the 0x20 character. one uses' b'the bioscom() function in bios.h the other uses the software interrupt' b'int86() function in dos.h. i have triple checked the baud rate b'the parity none the stop bits the character length bits b'and the interrupt calls for 0x14 currently, i am at a loss as' b'to what may be wrong. any hardware gurus out there want to comment?' b'' b'' b'thanks alot,' b'hubert de jesus' b'' b'' b'intel asm' b'' b'command equ 3000h ;command register on b'porta equ 3001h ;port a on b'timerlo equ 3004h ;high bits of timer' b'timerhi equ 3005h ;low bits of timer' b'uartdata equ e000h ;uart data register' b'uartcmd equ e001h ;uart command register' b'' b'org 4000h ;sram location' b'mvi a,08h\t\t ;set low timer bits' b'sta timerlo' b'mvi a,40h\t\t ;set high timer bits' b'sta timerhi' b'mvi a,11111101b ;start timer enable port a' b'sta command' b'' b'mvi a,11h ;display on 7-segment leds' b'sta porta' b'' b'mvi a,00h\t\t ;clear uart command' b'sta uartcmd' b'sta uartcmd' b'sta uartcmd' b'mvi a,01000000b\t\t ;internally reset uart' b'sta uartcmd' b'lda uartdata ;remove extraneous data' b'mvi a,01001111b ;init uart for data bits,' b'sta uartcmd no parity, stop bit, 64x async' b'mvi a,00100111b ;enable transmit and receive' b'sta uartcmd' b'' b'init: lda uartcmd\t\t ;read status register' b'ani 02h ;is rxrdy?' b'jz init ;no, loop' b'' b'lda uartdata ;read data character' b"cpi ;is character 0x20?" b'jnz init ;no, loop' b'' b'mvi a,22h ;character received,' b'sta porta display on 7-segment leds' b'hlt' b'end' b'' b'c++ using bioscom()' b'' b'#include <stdio.h' b'#include <stdlib.h' b'#include <bios.h' b'' b'#define init b'#define send b'#define receive b'#define status b'' b'#define com2 b'' b'void' b'main()' b'{' b'char abyte;' b'' b'abyte 0xa3;' b'bioscom( init, abyte, com2 b'printf( "initialized comm port 2\\n" b'' b'while( bioscom( status, com2 0x4000 b';' b"abyte b'bioscom( send, abyte, com2 b'printf( "sent start character\\n" b'}' b'' b'' b'c++ using int86()' b'' b'#include <stdio.h' b'#include <stdlib.h' b'#include <dos.h' b'#include <bios.h' b'' b'main()' b'{' b'union regs registers;' b'' b'registers.h.ah 0x00;' b'registers.h.al 0xa7;' b'registers.x.dx 0x01;' b'int86( 0x14, &registers, &registers b'printf( "com2 initialized\\n" b'' b'registers.h.ah 0x01;' b'registers.h.al 0x20;' b'registers.x.dx 0x01;' b'int86( 0x14, &registers, &registers b'printf( "sent start character\\n" b'}' 