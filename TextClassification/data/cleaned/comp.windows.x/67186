b'' b'|' b'| nick kisseberth) looks interesting, but i need someone to point me to some' b'| documentation. is this method likely to give better results than server-' b"| resident pixmaps? i'd also be interested in looking at the xview code" b'| mentioned above...' b'' b'there is no easy answer to this question: it depends on whether the display' b'device can hold pixmaps in off-screen memory, and if so, how efficiently' b'the server manages these resources (having to deal with limited off-screen' b"memory is the bane of the server implementor's existence!)." b'' b'i have worked with graphics devices where the off-screen memory to' b'main display copy rate eclipses that of the main memory to display copy' b'rate, and with those where the main memory to display is *faster* than' b'off-screen to display (requires only a write to the framebuffer rather' b'than a read of the f.b. followed by a write)' b'' b'if your server uses the cfb code or something like it to render into' b'pixmaps in cpu main memory, the rates you can get through mit-shm are' b"likely to be equal (maybe a tad slower, depending on your os's implementation" b'of shared memory) to copyarea from pixmap to window, which is also then' b'just a copy from cpu main memory to graphics device.' b'' b"one advanage of mit-shm is that if your images are large, you don't end up" b'growing the size of the server process to hold them.' b'' b'one disadvantage of the mit-shm is that, in its sample implementation,' b'there is no provision for elegantly cleaning up the shared memory segments' b'if the client dies a sudden, violent death (e.g., "kill"). you have to' b'be mindful of cluttering up the system with zombie shared memory segments.' b'' b'ken' b'--' b'kenneth whaley\t\t\t b'2630 walsh avenue' b'santa clara, ca. 