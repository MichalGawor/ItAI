b'' b'archive-name: cryptography-faq/part04' b'last-modified: b'' b'' b'faq for sci.crypt, part mathematical cryptology' b'' b'this is the fourth of ten parts of the sci.crypt faq. the parts are' b'mostly independent, but you should read the first part before the rest.' b"we don't have the time to send out missing parts by mail, so don't ask." b"notes such as ``[kah67]'' refer to the reference list in the last part." b'' b'the sections of this faq are available via anonymous ftp to rtfm.mit.edu' b'as /pub/usenet/news.answers/cryptography-faq/part[xx]. the cryptography' b'faq is posted to the newsgroups sci.crypt, sci.answers, and news.answers' b'every days.' b'' b'' b'contents:' b'' b'* in mathematical terms, what is a private-key cryptosystem?' b'* what is an attack?' b"* what's the advantage of formulating all this mathematically?" b'* why is the one-time pad secure?' b"* what's a ciphertext-only attack?" b"* what's a known-plaintext attack?" b"* what's a chosen-plaintext attack?" b'* in mathematical terms, what can you say about brute-force attacks?' b"* what's a key-guessing attack? what's entropy?" b'' b'' b'* in mathematical terms, what is a private-key cryptosystem?' b'' b'a private-key cryptosystem consists of an encryption system e and a' b'decryption system d. the encryption system e is a collection of' b"functions e_k, indexed by ``keys'' k, mapping some set of" b"``plaintexts'' p to some set of ``ciphertexts'' c. similarly the" b'decryption system d is a collection of functions d_k such that' b'd_k(e_k(p)) p for every plaintext p. that is, succesful decryption' b'of ciphertext into plaintext is accomplished using the same key' b'(index) as was used for the corresponding encryption of plaintext' b'into ciphertext. such systems, wherein the same key value is used to' b"encrypt and decrypt, are also known as ``symmetric'' cryptoystems." b'' b'* what is an attack?' b'' b'in intuitive terms a (passive) attack on a cryptosystem is any method' b'of starting with some information about plaintexts and their' b'corresponding ciphertexts under some (unknown) key, and figuring out' b"more information about the plaintexts. it's possible to state" b'mathematically what this means. here we go.' b'' b'fix functions f, g, and h of n variables. fix an encryption system e,' b'and fix a distribution of plaintexts and keys.' b'' b'an attack on e using g assuming f giving h with probability p is an' b'algorithm a with a pair f, g of inputs and one output h, such that' b'there is probability p of computing h h(p_1,...,p_n), if we have' b'f f(p_1,...,p_n) and g g(e_k(p_1),...,e_k(p_n)). note that this' b'probability depends on the distribution of the vector (k,p_1,...,p_n).' b'' b"the attack is trivial (or ``pointless'') if there is probability at" b'least p of computing h h(p_1,...,p_n) if f f(p_1,...,p_n) and' b'g g(c_1,...,c_n). here c_1,...,c_n range uniformly over the possible' b'ciphertexts, and have no particular relation to p_1,...,p_n. in other' b"words, an attack is trivial if it doesn't actually use the encryptions" b'e_k(p_1),...,e_k(p_n).' b'' b"an attack is called ``one-ciphertext'' if n ``two-ciphertext'' if" b'n and so on.' b'' b"* what's the advantage of formulating all this mathematically?" b'' b'in basic cryptology you can never prove that a cryptosystem is secure.' b'read part we keep saying ``a strong cryptosystem must have this' b'property, but having this property is no guarantee that a cryptosystem' b"is strong!''" b'' b'in contrast, the purpose of mathematical cryptology is to precisely' b'formulate and, if possible, prove the statement that a cryptosystem is' b'strong. we say, for example, that a cryptosystem is secure against' b'all (passive) attacks if any nontrivial attack against the system (as' b'defined above) is too slow to be practical. if we can prove this' b'statement then we have confidence that our cryptosystem will resist' b'any (passive) cryptanalytic technique. if we can reduce this statement' b'to some well-known unsolved problem then we still have confidence that' b"the cryptosystem isn't easy to break." b'' b'other parts of cryptology are also amenable to mathematical' b'definition. again the point is to explicitly identify what assumptions' b"we're making and prove that they produce the desired results. we can" b'figure out what it means for a particular cryptosystem to be used' b'properly: it just means that the assumptions are valid.' b'' b'the same methodology is useful for cryptanalysis too. the cryptanalyst' b'can take advantage of incorrect assumptions. often he can try to' b'construct a proof of security for a system, see where the proof fails,' b'and use these failures as the starting points for his analysis.' b'' b'* why is the one-time pad secure?' b'' b'by definition, the one-time pad is a cryptosystem where the' b'plaintexts, ciphertexts, and keys are all strings (say byte strings)' b"of some length m, and e_k(p) is just the sum (let's say the exclusive" b'or) of k and p.' b'' b'it is easy to prove mathematically that there are _no_ nontrivial' b'single-ciphertext attacks on the one-time pad, assuming a uniform' b"distribution of keys. note that we don't have to assume a uniform" b"distribution of plaintexts. (here's the proof: let a be an attack," b'i.e., an algorithm taking two inputs f, g and producing one output h,' b'with some probability p that h h(p) whenever f f(p) and' b'g g(e_k(p)) (i.e., g g(k p)). then, because the distribution of' b'k is uniform and independent of p, the distribution of k p must also' b'be uniform and independent of p. but also the distribution of c is' b'uniform and independent of p. hence there is probability exactly p' b'that h h(p) whenever f f(p) and g g(c), over all p and c. thus' b'a fortiori a is trivial.)' b'' b'on the other hand the one-time pad is _not_ secure if a key k is used' b'for more than one plaintext: i.e., there are nontrivial' b'multiple-ciphertext attacks. so to be properly used a key k must be' b"thrown away after one encryption. the key is also called a ``pad'';" b"this explains the name ``one-time pad.''" b'' b"* what's a ciphertext-only attack?" b'' b'in the notation above, a ciphertext-only attack is one where f is' b'constant. given only some information g(e_k(p_1),...,e_k(p_n)) about' b'n ciphertexts, the attack has to have some chance of producing some' b'information h(p_1,...,p_n) about the plaintexts. the attack is trivial' b'if it has just as good a chance of producing h(p_1,...,p_n) when given' b'g(c_1,...,c_n) for random c_1,...,c_n.' b'' b'for example, say g(c) c, and say h(p) is the first bit of p. we can' b"easily write down an attack---the ``guessing attack,'' which simply" b"guesses that h(p) is this attack is trivial because it doesn't use" b'the ciphertext: it has a fifty-fifty chance of guessing correctly no' b'matter what. on the other hand there is an attack on rsa which' b'produces one bit of information about p, with success, using c.' b'if it is fed a random c then the success rate drops to so this is' b'a nontrivial attack.' b'' b"* what's a known-plaintext attack?" b'' b'the classic known-plaintext attack has f(p_1,p_2) p_1,' b'g(c_1,c_2) (c_1,c_2), and h(p_1,p_2) depending only on p_2.' b'in other words, given two ciphertexts c_1 and c_2 and one decryption' b'p_1, the known-plaintext attack should produce information about the' b'other decryption p_2.' b'' b'note that known-plaintext attacks are often defined in the literature' b'as producing information about the key, but this is pointless: the' b'cryptanalyst generally cares about the key only insofar as it lets him' b'decrypt further messages.' b'' b"* what's a chosen-plaintext attack?" b'' b'a chosen-plaintext attack is the first of an increasingly impractical' b'series of _active_ attacks on a cryptosystem: attacks where the' b"cryptanalyst feeds data to the encryptor. these attacks don't fit into" b'our model of passive attacks explained above. anyway, a' b'chosen-plaintext attack lets the cryptanalyst choose a plaintext and' b'look at the corresponding ciphertext, then repeat until he has figured' b'out how to decrypt any message. more absurd examples of this sort of' b"attack are the ``chosen-key attack'' and ``chosen-system attack.''" b'' b'a much more important form of active attack is a message corruption' b'attack, where the attacker tries to change the ciphertext in such a' b'way as to make a useful change in the plaintext.' b'' b'there are many easy ways to throw kinks into all of these attacks:' b'for instance, automatically encrypting any plaintext p as' b't,e_k(h(t+r+p),r,p), where t is a time-key (sequence number) chosen anew' b'for each message, r is a random number, and h is a one-way hash' b'function. here comma means concatenation and plus means exclusive-or.' b'' b'* in mathematical terms, what can you say about brute-force attacks?' b'' b'consider the following known-plaintext attack. we are given some' b"plaintexts p_1,...,p_{n-1} and ciphertexts c_1,...,c_{n-1}. we're" b'also given a ciphertext c_n. we run through every key k. when we find' b'k such that e_k(p_i) c_i for every i n, we print d_k(c_n).' b'' b'if n is big enough that only one key works, this attack will succeed' b'on valid inputs all the time, while it will produce correct results' b'only once in a blue moon for random inputs. thus this is a nontrivial' b'attack. its only problem is that it is very slow if there are many' b'possible keys.' b'' b"* what's a key-guessing attack? what's entropy?" b'' b"say somebody is using the one-time pad---but isn't choosing keys" b'randomly and uniformly from all m-bit messages, as he was supposed to' b"for our security proof. in fact say he's known to prefer keys which" b'are english words. then a cryptanalyst can run through all english' b"words as possible keys. this attack will often succeed, and it's much" b'faster than a brute-force search of the entire keyspace.' b'' b'we can measure how bad a key distribution is by calculating its' b"entropy. this number e is the number of ``real bits of information''" b'of the key: a cryptanalyst will typically happen across the key within' b'2^e guesses. e is defined as the sum of -p_k log_2 p_k, where p_k is' b'the probability of key k.' 